var tipuesearch = {"pages":[{"text":"dop853 Brief description This is a modern Fortran (2003/2008) implementation of Hairer's DOP853 ODE solver. The original FORTRAN 77 code has been extensively refactored, and is now object-oriented and thread-safe, with an easy-to-use class interface.  DOP853 is an explicit Runge-Kutta method of order 8(5,3) due to Dormand & Prince (with stepsize control and dense output). This project is hosted on GitHub . References E. Hairer, S.P. Norsett and G. Wanner, \" Solving ordinary\n   Differential Equations I. Nonstiff Problems \", 2nd edition.\n   Springer Series in Computational Mathematics,\n   Springer-Verlag (1993). Ernst Hairer's website: Fortran and Matlab Codes License Original license for Hairer's codes . The updates are released under a similar BSD-style license . Developer Info Jacob Williams","tags":"","loc":"index.html","title":" dop853 "},{"text":"Source Code !***************************************************************************************** !> author: Jacob Williams ! !  Modern Fortran Edition of the DOP853 ODE Solver. ! !# See also !   * [DOP853.f](http://www.unige.ch/~hairer/prog/nonstiff/dop853.f) ! !# History !   * Jacob Williams : December 2015 : Created module from the DOP853 Fortran 77 code. !   * Development continues at [GitHub](https://github.com/jacobwilliams/dop853). ! !# License ! !###Original DOP853 license: ! !        Copyright (c) 2004, Ernst Hairer ! !        Redistribution and use in source and binary forms, with or without !        modification, are permitted provided that the following conditions are !        met: ! !        - Redistributions of source code must retain the above copyright !        notice, this list of conditions and the following disclaimer. ! !        - Redistributions in binary form must reproduce the above copyright !        notice, this list of conditions and the following disclaimer in the !        documentation and/or other materials provided with the distribution. ! !        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS !        IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED !        TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A !        PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR !        CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, !        EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, !        PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR !        PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF !        LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING !        NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS !        SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! !###License for updated version: ! !        Modern Fortran Edition of the DOP853 ODE Solver !        https://github.com/jacobwilliams/dop853 ! !        Copyright (c) 2015, Jacob Williams !        All rights reserved. ! !        Redistribution and use in source and binary forms, with or without modification, !        are permitted provided that the following conditions are met: ! !        * Redistributions of source code must retain the above copyright notice, this !          list of conditions and the following disclaimer. ! !        * Redistributions in binary form must reproduce the above copyright notice, this !          list of conditions and the following disclaimer in the documentation and/or !          other materials provided with the distribution. ! !        * The names of its contributors may not be used to endorse or promote products !          derived from this software without specific prior written permission. ! !        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND !        ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED !        WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE !        DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR !        ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES !        (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; !        LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON !        ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT !        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS !        SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! !***************************************************************************************** module dop853_module use dop853_constants use iso_fortran_env , only : output_unit , error_unit implicit none type , public :: dop853_class private !internal variables: integer :: n = 0 !! the dimension of the system integer :: nfcn = 0 !! number of function evaluations integer :: nstep = 0 !! number of computed steps integer :: naccpt = 0 !! number of accepted steps integer :: nrejct = 0 !! number of rejected steps (due to error test), !! (step rejections in the first step are not counted) integer :: nrdens = 0 !! number of components, for which dense output !! is required. for `0 < nrdens < n` the components !! (for which dense output is required) have to be !! specified in `icomp(1),...,icomp(nrdens)`. real ( wp ) :: h = 0.0_wp !! predicted step size of the last accepted step !input paramters: !  these parameters allow !  to adapt the code to the problem and to the needs of !  the user. set them on class initialization. integer :: iprint = output_unit !! switch for printing error messages !! if `iprint==0` no messages are being printed !! if `iprint/=0` messages are printed with !! `write (iprint,*)` ... integer :: nmax = 100000 !! the maximal number of allowed steps. integer :: nstiff = 1000 !! test for stiffness is activated after step number !! `j*nstiff` (`j` integer), provided `nstiff>0`. !! for negative `nstiff` the stiffness test is !! never activated. real ( wp ) :: hinitial = 0.0_wp !! initial step size, for `hinitial=0` an initial guess !! is computed with help of the function [[hinit]]. real ( wp ) :: hmax = 0.0_wp !! maximal step size, defaults to `xend-x` if `hmax=0`. real ( wp ) :: safe = 0.9_wp !! safety factor in step size prediction real ( wp ) :: fac1 = 0.333_wp !! parameter for step size selection. !! the new step size is chosen subject to the restriction !! `fac1 <= hnew/hold <= fac2` real ( wp ) :: fac2 = 6.0_wp !! parameter for step size selection. !! the new step size is chosen subject to the restriction !! `fac1 <= hnew/hold <= fac2` real ( wp ) :: beta = 0.0_wp !! is the `beta` for stabilized step size control !! (see section iv.2). positive values of beta ( <= 0.04 ) !! make the step size control more stable. integer , dimension (:), allocatable :: icomp !! `dimension(nrdens)` !! the components for which dense output is required real ( wp ), dimension (:), allocatable :: cont !! `dimension(8*nrdens)` !formerly in the condo8 common block: real ( wp ) :: xold = 0.0_wp real ( wp ) :: hout = 0.0_wp !user-defined procedures: procedure ( deriv_func ), pointer :: fcn => null () !! subroutine computing the value of `f(x,y)` procedure ( solout_func ), pointer :: solout => null () !! subroutine providing the !! numerical solution during integration. !! if `iout>=1`, it is called during integration. contains private procedure , public :: initialize => set_parameters !! initialization routine. procedure , public :: integrate => dop853 !! main integration routine. procedure , public :: destroy => destroy_dop853 !! destructor. procedure , public :: info => get_dop853_info !! to get info after a run. procedure :: dp86co procedure :: hinit procedure , public :: contd8 !! can be called in user's [[solout_func]] for dense output. end type dop853_class abstract interface subroutine deriv_func ( me , x , y , f ) !! subroutine computing the value of  dy/dx = f(x,y)  import :: wp , dop853_class implicit none class ( dop853_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x !! independent variable x real ( wp ), dimension (:), intent ( in ) :: y !! state vector  y(x)  [size n] real ( wp ), dimension (:), intent ( out ) :: f !! derivative vector  f(x,y) = dy/dx  [size n] end subroutine deriv_func subroutine solout_func ( me , nr , xold , x , y , irtrn , xout ) !! `solout` furnishes the solution `y` at the `nr`-th !! grid-point `x` (thereby the initial value is !! the first grid-point). import :: wp , dop853_class implicit none class ( dop853_class ), intent ( inout ) :: me integer , intent ( in ) :: nr !! grid point (0,1,...) real ( wp ), intent ( in ) :: xold !! the preceeding grid point real ( wp ), intent ( in ) :: x !! current grid point real ( wp ), dimension (:), intent ( in ) :: y !! state vector  y(x)  [size n] integer , intent ( inout ) :: irtrn !! serves to interrupt the integration. if !! `irtrn` is set `<0`, [[dop853]] will return to !! the calling program. if the numerical solution !! is altered in `solout`, set `irtrn = 2`. real ( wp ), intent ( out ) :: xout !! `xout` can be used for efficient intermediate output !! if one puts `iout=3`. when `nr=1` define the first !! output point `xout` in `solout`. the subroutine !! `solout` will be called only when `xout` is in the !! interval `[xold,x]`; during this call !! a new value for `xout` can be defined, etc. end subroutine solout_func end interface contains !***************************************************************************************** !***************************************************************************************** !> !  Get info from a [[dop853_class]]. subroutine get_dop853_info ( me , n , nfcn , nstep , naccpt , nrejct , h ) implicit none class ( dop853_class ), intent ( in ) :: me integer , intent ( out ), optional :: n !! dimension of the system integer , intent ( out ), optional :: nfcn !! number of function evaluations integer , intent ( out ), optional :: nstep !! number of computed steps integer , intent ( out ), optional :: naccpt !! number of accepted steps integer , intent ( out ), optional :: nrejct !! number of rejected steps (due to error test), !! (step rejections in the first step are not counted) real ( wp ), intent ( out ), optional :: h !! predicted step size of the last accepted step if ( present ( n )) n = me % n if ( present ( nfcn )) nfcn = me % nfcn if ( present ( nstep )) nstep = me % nstep if ( present ( naccpt )) naccpt = me % naccpt if ( present ( nrejct )) nrejct = me % nrejct if ( present ( h )) h = me % h end subroutine get_dop853_info !***************************************************************************************** !***************************************************************************************** !> !  Destructor for [[dop853_class]]. subroutine destroy_dop853 ( me ) implicit none class ( dop853_class ), intent ( out ) :: me end subroutine destroy_dop853 !***************************************************************************************** !***************************************************************************************** !> !  Set the optional inputs for [[dop853]]. ! !@note In the original code, these were part of the `work` and `iwork` arrays. subroutine set_parameters ( me , n , fcn , solout , iprint , nstiff , nmax , hinitial ,& hmax , safe , fac1 , fac2 , beta , icomp , status_ok ) implicit none class ( dop853_class ), intent ( inout ) :: me integer , intent ( in ) :: n !! the dimension of the system (size of y and y' vectors) procedure ( deriv_func ) :: fcn !! subroutine computing the value of  y' = f(x,y)  procedure ( solout_func ), optional :: solout !! subroutine providing the !! numerical solution during integration. !! if `iout>=1`, it is called during integration. !! supply a dummy subroutine if `iout=0`. integer , intent ( in ), optional :: iprint !! switch for printing error messages !! if `iprint==0` no messages are being printed !! if `iprint/=0` messages are printed with !! `write (iprint,*)` ... integer , intent ( in ), optional :: nstiff !! test for stiffness is activated after step number !! `j*nstiff` (`j` integer), provided `nstiff>0`. !! for negative `nstiff` the stiffness test is !! never activated. integer , intent ( in ), optional :: nmax !! the maximal number of allowed steps. real ( wp ), intent ( in ), optional :: hinitial !! initial step size, for `hinitial=0` an initial guess !! is computed with help of the function [[hinit]]. real ( wp ), intent ( in ), optional :: hmax !! maximal step size, defaults to `xend-x` if `hmax=0`. real ( wp ), intent ( in ), optional :: safe !! safety factor in step size prediction real ( wp ), intent ( in ), optional :: fac1 !! parameter for step size selection. !! the new step size is chosen subject to the restriction !! `fac1 <= hnew/hold <= fac2` real ( wp ), intent ( in ), optional :: fac2 !! parameter for step size selection. !! the new step size is chosen subject to the restriction !! `fac1 <= hnew/hold <= fac2` real ( wp ), intent ( in ), optional :: beta !! is the `beta` for stabilized step size control !! (see section iv.2). positive values of `beta` ( <= 0.04 ) !! make the step size control more stable. integer , dimension (:), intent ( in ), optional :: icomp !! the components for which dense output is required (size from 0 to `n`). logical , intent ( out ) :: status_ok !! will be false for invalid inputs. call me % destroy () status_ok = . true . !required inputs: me % n = n me % fcn => fcn !optional inputs: if ( present ( solout )) me % solout => solout if ( present ( iprint )) me % iprint = iprint if ( present ( nstiff )) me % nstiff = nstiff if ( present ( hinitial )) me % hinitial = hinitial if ( present ( hmax )) me % hmax = hmax if ( present ( fac1 )) me % fac1 = fac1 if ( present ( fac2 )) me % fac2 = fac2 if ( present ( nmax )) then if ( nmax <= 0 ) then if ( me % iprint /= 0 ) & write ( me % iprint , * ) ' wrong input nmax=' , nmax status_ok = . false . else me % nmax = nmax end if end if if ( present ( safe )) then if ( safe >= 1.0_wp . or . safe <= 1.0e-4_wp ) then if ( me % iprint /= 0 ) & write ( me % iprint , * ) ' curious input for safety factor safe:' , & safe status_ok = . false . else me % safe = safe end if end if if ( present ( beta )) then if ( beta <= 0.0_wp ) then me % beta = 0.0_wp else if ( beta > 0.2_wp ) then if ( me % iprint /= 0 ) write ( me % iprint , * ) & ' curious input for beta: ' , beta status_ok = . false . else me % beta = beta end if end if end if if ( present ( icomp )) then me % nrdens = size ( icomp ) !check validity of icomp array: if ( size ( icomp ) <= me % n . and . all ( icomp > 0 . and . icomp <= me % n )) then allocate ( me % icomp ( me % nrdens )); me % icomp = icomp allocate ( me % cont ( 8 * me % nrdens )); me % cont = 0.0_wp else if ( me % iprint /= 0 ) write ( me % iprint , * ) & ' invalid icomp array: ' , icomp status_ok = . false . end if end if end subroutine set_parameters !***************************************************************************************** !***************************************************************************************** !> !  Numerical solution of a system of first order !  ordinary differential equations  y'=f(x,y) . !  This is an explicit Runge-Kutta method of order 8(5,3) !  due to Dormand & Prince (with stepsize control and !  dense output). ! !# Authors !  * E. Hairer and G. Wanner !    Universite de Geneve, Dept. De Mathematiques !    ch-1211 geneve 24, switzerland !    e-mail:  ernst.hairer@unige.ch !             gerhard.wanner@unige.ch !  * Version of October 11, 2009 !    (new option `iout=3` for sparse dense output) !  * Jacob Williams, Dec 2015: significant refactoring into modern Fortran. ! !# Reference !  * E. Hairer, S.P. Norsett and G. Wanner, [Solving Ordinary !    Differential Equations I. Nonstiff Problems. 2nd Edition](http://www.unige.ch/~hairer/books.html). !    Springer Series in Computational Mathematics, Springer-Verlag (1993) subroutine dop853 ( me , x , y , xend , rtol , atol , iout , idid ) implicit none class ( dop853_class ), intent ( inout ) :: me real ( wp ), intent ( inout ) :: x !! *input:* initial value of independent variable. !! *output:* `x` for which the solution has been computed !! (after successful return `x=xend`). real ( wp ), dimension (:), intent ( inout ) :: y !! *input:* initial values for `y`. [size n] !! *output:* numerical solution at `x`. real ( wp ), intent ( in ) :: xend !! final x-value (xend-x may be positive or negative) real ( wp ), dimension (:), intent ( in ) :: rtol !! relative error tolerance. `rtol` and `atol` !! can be both scalars or else both vectors of length `n`. real ( wp ), dimension (:), intent ( in ) :: atol !! absolute error tolerance. `rtol` and `atol` !! can be both scalars or else both vectors of length `n`. !! `atol` should be strictly positive (possibly very small) integer , intent ( in ) :: iout !! switch for calling the subroutine `solout`: !!  `iout=0`: subroutine is never called !!  `iout=1`: subroutine is called after every successful step !!  `iout=2`: dense output is performed after every successful step !!  `iout=3`: dense output is performed in steps defined by the user !!          (see `xout` above) integer , intent ( out ) :: idid !! reports on successfulness upon return: !!  `idid=1`  computation successful, !!  `idid=2`  comput. successful (interrupted by [[solout]]), !!  `idid=-1` input is not consistent, !!  `idid=-2` larger `nmax` is needed, !!  `idid=-3` step size becomes too small. !!  `idid=-4` problem is probably stiff (interrupted). real ( wp ) :: beta , fac1 , fac2 , h , hmax , safe integer :: i , ieco , iprint , istore , nrdens , nstiff , nmax logical :: arret integer :: itol !! switch for `rtol` and `atol`: !!  `itol=0`: both `rtol` and `atol` are scalars. !!    the code keeps, roughly, the local error of !!    `y(i)` below `rtol*abs(y(i))+atol`. !!  `itol=1`: both `rtol` and `atol` are vectors. !!    the code keeps the local error of `y(i)` below !!    `rtol(i)*abs(y(i))+atol(i)`. iprint = me % iprint arret = . false . !check procedures: if (. not . associated ( me % fcn )) then if ( iprint /= 0 ) & write ( iprint , * ) & 'Error in dop853: procedure FCN is not associated.' idid = - 1 return end if if ( iout /= 0 . and . . not . associated ( me % solout )) then if ( iprint /= 0 ) & write ( iprint , * ) & 'Error in dop853: procedure SOLOUT must be associated if IOUT/=0.' idid = - 1 return end if !scalar or vector tolerances: if ( size ( rtol ) == 1 . and . size ( atol ) == 1 ) then itol = 0 elseif ( size ( rtol ) == me % n . and . size ( atol ) == me % n ) then itol = 1 else if ( iprint /= 0 ) & write ( iprint , * ) & 'Error in dop853: improper dimensions for rtol and/or atol.' idid = - 1 return end if ! setting the parameters me % nfcn = 0 me % nstep = 0 me % naccpt = 0 me % nrejct = 0 nmax = me % nmax nrdens = me % nrdens !number of dense output components ! nstiff parameter for stiffness detection if ( me % nstiff <= 0 ) then nstiff = nmax + 10 !no stiffness check else nstiff = me % nstiff end if if ( nrdens < 0 . or . me % nrdens > me % n ) then if ( iprint /= 0 ) write ( iprint , * ) ' curious input nrdens=' , nrdens arret = . true . else if ( nrdens > 0 . and . iout < 2 . and . iprint /= 0 ) & write ( iprint , * ) ' warning: set iout=2 or iout=3 for dense output ' end if if ( size ( y ) /= me % n ) then if ( iprint /= 0 ) & write ( iprint , * ) ' error: y must have n elements: size(y)= ' , size ( y ) arret = . true . end if safe = me % safe fac1 = me % fac1 fac2 = me % fac2 beta = me % beta if ( me % hmax == 0.0_wp ) then hmax = xend - x else hmax = me % hmax end if h = me % hinitial ! initial step size me % h = h ! when a fail has occured, we return with idid=-1 if ( arret ) then idid = - 1 else ! call to core integrator call me % dp86co ( x , y , xend , hmax , h , rtol , atol , itol , iprint , & iout , idid , nmax , nstiff , safe , beta , fac1 , fac2 , & me % nfcn , me % nstep , me % naccpt , me % nrejct ) me % h = h ! may have been updated end if end subroutine dop853 !***************************************************************************************** !***************************************************************************************** !> !  Core integrator for [[dop853]]. !  parameters same as in [[dop853]] with workspace added. subroutine dp86co ( me , x , y , xend , hmax , h , rtol , atol , itol , iprint , & iout , idid , nmax , nstiff , safe , & beta , fac1 , fac2 , & nfcn , nstep , naccpt , nrejct ) implicit none class ( dop853_class ), intent ( inout ) :: me real ( wp ), intent ( inout ) :: x real ( wp ), dimension (:), intent ( inout ) :: y real ( wp ), intent ( in ) :: xend real ( wp ), intent ( inout ) :: hmax real ( wp ), intent ( inout ) :: h real ( wp ), dimension (:), intent ( in ) :: rtol real ( wp ), dimension (:), intent ( in ) :: atol integer , intent ( in ) :: itol integer , intent ( in ) :: iprint integer , intent ( in ) :: iout integer , intent ( out ) :: idid integer , intent ( in ) :: nmax integer , intent ( in ) :: nstiff real ( wp ), intent ( in ) :: safe real ( wp ), intent ( in ) :: beta real ( wp ), intent ( in ) :: fac1 real ( wp ), intent ( in ) :: fac2 integer , intent ( inout ) :: nfcn integer , intent ( inout ) :: nstep integer , intent ( inout ) :: naccpt integer , intent ( inout ) :: nrejct real ( wp ), dimension ( me % n ) :: y1 , k1 , k2 , k3 , k4 , k5 , k6 , k7 , k8 , k9 , k10 real ( wp ) :: atoli , bspl , deno , err , err2 , erri , expo1 , fac , fac11 ,& facc1 , facc2 , facold , hlamb , hnew , posneg , rtoli ,& sk , stden , stnum , xout , xph , ydiff integer :: i , iasti , iord , irtrn , j , nonsti , nrd logical :: reject , last , event , abort ! initialisations nrd = me % nrdens facold = 1.0e-4_wp expo1 = 1.0_wp / 8.0_wp - beta * 0.2_wp facc1 = 1.0_wp / fac1 facc2 = 1.0_wp / fac2 posneg = sign ( 1.0_wp , xend - x ) ! initial preparations atoli = atol ( 1 ) rtoli = rtol ( 1 ) last = . false . hlamb = 0.0_wp iasti = 0 call me % fcn ( x , y , k1 ) hmax = abs ( hmax ) iord = 8 if ( h == 0.0_wp ) then h = me % hinit ( x , y , posneg , k1 , iord , hmax , atol , rtol , itol ) end if nfcn = nfcn + 2 reject = . false . me % xold = x if ( iout /= 0 ) then irtrn = 1 me % hout = 1.0_wp call me % solout ( naccpt + 1 , me % xold , x , y , irtrn , xout ) abort = ( irtrn < 0 ) else abort = . false . end if if (. not . abort ) then do ! basic integration step if ( nstep > nmax ) then if ( iprint /= 0 ) & write ( iprint , '(A,E18.4)' ) ' exit of dop853 at x=' , x if ( iprint /= 0 ) & write ( iprint , * ) ' more than nmax =' , nmax , 'steps are needed' idid = - 2 return elseif ( 0.1_wp * abs ( h ) <= abs ( x ) * uround ) then if ( iprint /= 0 ) & write ( iprint , '(A,E18.4)' ) ' exit of dop853 at x=' , x if ( iprint /= 0 ) & write ( iprint , * ) ' step size too small, h=' , h idid = - 3 return else if ( ( x + 1.01_wp * h - xend ) * posneg > 0.0_wp ) then h = xend - x last = . true . end if nstep = nstep + 1 ! the twelve stages if ( irtrn >= 2 ) call me % fcn ( x , y , k1 ) y1 = y + h * a21 * k1 call me % fcn ( x + c2 * h , y1 , k2 ) y1 = y + h * ( a31 * k1 + a32 * k2 ) call me % fcn ( x + c3 * h , y1 , k3 ) y1 = y + h * ( a41 * k1 + a43 * k3 ) call me % fcn ( x + c4 * h , y1 , k4 ) y1 = y + h * ( a51 * k1 + a53 * k3 + a54 * k4 ) call me % fcn ( x + c5 * h , y1 , k5 ) y1 = y + h * ( a61 * k1 + a64 * k4 + a65 * k5 ) call me % fcn ( x + c6 * h , y1 , k6 ) y1 = y + h * ( a71 * k1 + a74 * k4 + a75 * k5 + a76 * k6 ) call me % fcn ( x + c7 * h , y1 , k7 ) y1 = y + h * ( a81 * k1 + a84 * k4 + a85 * k5 + a86 * k6 + a87 * k7 ) call me % fcn ( x + c8 * h , y1 , k8 ) y1 = y + h * ( a91 * k1 + a94 * k4 + a95 * k5 + a96 * k6 + a97 * k7 + a98 * k8 ) call me % fcn ( x + c9 * h , y1 , k9 ) y1 = y + h * ( a101 * k1 + a104 * k4 + a105 * k5 + a106 * k6 + a107 * k7 + & a108 * k8 + a109 * k9 ) call me % fcn ( x + c10 * h , y1 , k10 ) y1 = y + h * ( a111 * k1 + a114 * k4 + a115 * k5 + a116 * k6 + a117 * k7 + & a118 * k8 + a119 * k9 + a1110 * k10 ) call me % fcn ( x + c11 * h , y1 , k2 ) xph = x + h y1 = y + h * ( a121 * k1 + a124 * k4 + a125 * k5 + a126 * k6 + a127 * k7 + & a128 * k8 + a129 * k9 + a1210 * k10 + a1211 * k2 ) call me % fcn ( xph , y1 , k3 ) nfcn = nfcn + 11 k4 = b1 * k1 + b6 * k6 + b7 * k7 + b8 * k8 + b9 * k9 + b10 * k10 + b11 * k2 + b12 * k3 k5 = y + h * k4 ! error estimation err = 0.0_wp err2 = 0.0_wp if ( itol == 0 ) then do i = 1 , me % n sk = atoli + rtoli * max ( abs ( y ( i )), abs ( k5 ( i ))) erri = k4 ( i ) - bhh1 * k1 ( i ) - bhh2 * k9 ( i ) - bhh3 * k3 ( i ) err2 = err2 + ( erri / sk ) ** 2 erri = er1 * k1 ( i ) + er6 * k6 ( i ) + er7 * k7 ( i ) + er8 * k8 ( i ) & + er9 * k9 ( i ) + er10 * k10 ( i ) + er11 * k2 ( i ) & + er12 * k3 ( i ) err = err + ( erri / sk ) ** 2 end do else do i = 1 , me % n sk = atol ( i ) + rtol ( i ) * max ( abs ( y ( i )), abs ( k5 ( i ))) erri = k4 ( i ) - bhh1 * k1 ( i ) - bhh2 * k9 ( i ) - bhh3 * k3 ( i ) err2 = err2 + ( erri / sk ) ** 2 erri = er1 * k1 ( i ) + er6 * k6 ( i ) + er7 * k7 ( i ) + er8 * k8 ( i ) & + er9 * k9 ( i ) + er10 * k10 ( i ) + er11 * k2 ( i ) & + er12 * k3 ( i ) err = err + ( erri / sk ) ** 2 end do end if deno = err + 0.01_wp * err2 if ( deno <= 0.0_wp ) deno = 1.0_wp err = abs ( h ) * err * sqrt ( 1.0_wp / ( me % n * deno )) ! computation of hnew fac11 = err ** expo1 ! lund-stabilization fac = fac11 / facold ** beta ! we require  fac1 <= hnew/h <= fac2 fac = max ( facc2 , min ( facc1 , fac / safe )) hnew = h / fac if ( err <= 1.0_wp ) then ! step is accepted facold = max ( err , 1.0e-4_wp ) naccpt = naccpt + 1 call me % fcn ( xph , k5 , k4 ) nfcn = nfcn + 1 ! stiffness detection if ( mod ( naccpt , nstiff ) == 0 . or . iasti > 0 ) then stnum = 0.0_wp stden = 0.0_wp do i = 1 , me % n stnum = stnum + ( k4 ( i ) - k3 ( i )) ** 2 stden = stden + ( k5 ( i ) - y1 ( i )) ** 2 end do if ( stden > 0.0_wp ) hlamb = abs ( h ) * sqrt ( stnum / stden ) if ( hlamb > 6.1_wp ) then nonsti = 0 iasti = iasti + 1 if ( iasti == 15 ) then if ( iprint /= 0 ) & write ( iprint , * ) & ' the problem seems to become stiff at x = ' , x if ( iprint == 0 ) then idid = - 4 ! fail exit return end if end if else nonsti = nonsti + 1 if ( nonsti == 6 ) iasti = 0 end if end if ! final preparation for dense output event = ( iout == 3 ) . and . ( xout <= xph ) if ( iout == 2 . or . event ) then ! save the first function evaluations do j = 1 , nrd i = me % icomp ( j ) me % cont ( j ) = y ( i ) ydiff = k5 ( i ) - y ( i ) me % cont ( j + nrd ) = ydiff bspl = h * k1 ( i ) - ydiff me % cont ( j + nrd * 2 ) = bspl me % cont ( j + nrd * 3 ) = ydiff - h * k4 ( i ) - bspl me % cont ( j + nrd * 4 ) = d41 * k1 ( i ) + d46 * k6 ( i ) + d47 * k7 ( i ) + & d48 * k8 ( i ) + d49 * k9 ( i ) + d410 * k10 ( i ) + & d411 * k2 ( i ) + d412 * k3 ( i ) me % cont ( j + nrd * 5 ) = d51 * k1 ( i ) + d56 * k6 ( i ) + d57 * k7 ( i ) + & d58 * k8 ( i ) + d59 * k9 ( i ) + d510 * k10 ( i ) + & d511 * k2 ( i ) + d512 * k3 ( i ) me % cont ( j + nrd * 6 ) = d61 * k1 ( i ) + d66 * k6 ( i ) + d67 * k7 ( i ) + & d68 * k8 ( i ) + d69 * k9 ( i ) + d610 * k10 ( i ) + & d611 * k2 ( i ) + d612 * k3 ( i ) me % cont ( j + nrd * 7 ) = d71 * k1 ( i ) + d76 * k6 ( i ) + d77 * k7 ( i ) + & d78 * k8 ( i ) + d79 * k9 ( i ) + d710 * k10 ( i ) + & d711 * k2 ( i ) + d712 * k3 ( i ) end do ! the next three function evaluations y1 = y + h * ( a141 * k1 + a147 * k7 + a148 * k8 + a149 * k9 + & a1410 * k10 + a1411 * k2 + a1412 * k3 + a1413 * k4 ) call me % fcn ( x + c14 * h , y1 , k10 ) y1 = y + h * ( a151 * k1 + a156 * k6 + a157 * k7 + a158 * k8 + & a1511 * k2 + a1512 * k3 + a1513 * k4 + a1514 * k10 ) call me % fcn ( x + c15 * h , y1 , k2 ) y1 = y + h * ( a161 * k1 + a166 * k6 + a167 * k7 + a168 * k8 + a169 * k9 + & a1613 * k4 + a1614 * k10 + a1615 * k2 ) call me % fcn ( x + c16 * h , y1 , k3 ) nfcn = nfcn + 3 ! final preparation do j = 1 , nrd i = me % icomp ( j ) me % cont ( j + nrd * 4 ) = h * ( me % cont ( j + nrd * 4 ) + d413 * k4 ( i ) + & d414 * k10 ( i ) + d415 * k2 ( i ) + d416 * k3 ( i )) me % cont ( j + nrd * 5 ) = h * ( me % cont ( j + nrd * 5 ) + d513 * k4 ( i ) + & d514 * k10 ( i ) + d515 * k2 ( i ) + d516 * k3 ( i )) me % cont ( j + nrd * 6 ) = h * ( me % cont ( j + nrd * 6 ) + d613 * k4 ( i ) + & d614 * k10 ( i ) + d615 * k2 ( i ) + d616 * k3 ( i )) me % cont ( j + nrd * 7 ) = h * ( me % cont ( j + nrd * 7 ) + d713 * k4 ( i ) + & d714 * k10 ( i ) + d715 * k2 ( i ) + d716 * k3 ( i )) end do me % hout = h end if k1 = k4 y = k5 me % xold = x x = xph if ( iout == 1 . or . iout == 2 . or . event ) then call me % solout ( naccpt + 1 , me % xold , x , y , irtrn , xout ) if ( irtrn < 0 ) exit !abort end if ! normal exit if ( last ) then h = hnew idid = 1 return end if if ( abs ( hnew ) > hmax ) hnew = posneg * hmax if ( reject ) hnew = posneg * min ( abs ( hnew ), abs ( h )) reject = . false . else ! step is rejected hnew = h / min ( facc1 , fac11 / safe ) reject = . true . if ( naccpt >= 1 ) nrejct = nrejct + 1 last = . false . end if h = hnew end if end do end if if ( iprint /= 0 ) write ( iprint , '(A,E18.4)' ) ' exit of dop853 at x=' , x idid = 2 end subroutine dp86co !***************************************************************************************** !***************************************************************************************** !> !  computation of an initial step size guess function hinit ( me , x , y , posneg , f0 , iord , hmax , atol , rtol , itol ) implicit none class ( dop853_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y !! dimension(n) real ( wp ), intent ( in ) :: posneg real ( wp ), dimension (:), intent ( in ) :: f0 !! dimension(n) integer , intent ( in ) :: iord real ( wp ), intent ( in ) :: hmax real ( wp ), dimension (:), intent ( in ) :: atol real ( wp ), dimension (:), intent ( in ) :: rtol integer , intent ( in ) :: itol real ( wp ) :: atoli , der12 , der2 , dnf , dny , h , h1 , hinit , rtoli , sk integer :: i real ( wp ), dimension ( me % n ) :: f1 , y1 ! compute a first guess for explicit euler as !   h = 0.01 * norm (y0) / norm (f0) ! the increment for explicit euler is small ! compared to the solution dnf = 0.0_wp dny = 0.0_wp atoli = atol ( 1 ) rtoli = rtol ( 1 ) if ( itol == 0 ) then do i = 1 , me % n sk = atoli + rtoli * abs ( y ( i )) dnf = dnf + ( f0 ( i ) / sk ) ** 2 dny = dny + ( y ( i ) / sk ) ** 2 end do else do i = 1 , me % n sk = atol ( i ) + rtol ( i ) * abs ( y ( i )) dnf = dnf + ( f0 ( i ) / sk ) ** 2 dny = dny + ( y ( i ) / sk ) ** 2 end do end if if ( dnf <= 1.0e-10_wp . or . dny <= 1.0e-10_wp ) then h = 1.0e-6_wp else h = sqrt ( dny / dnf ) * 0.01_wp end if h = min ( h , hmax ) h = sign ( h , posneg ) ! perform an explicit euler step do i = 1 , me % n y1 ( i ) = y ( i ) + h * f0 ( i ) end do call me % fcn ( x + h , y1 , f1 ) ! estimate the second derivative of the solution der2 = 0.0_wp if ( itol == 0 ) then do i = 1 , me % n sk = atoli + rtoli * abs ( y ( i )) der2 = der2 + (( f1 ( i ) - f0 ( i )) / sk ) ** 2 end do else do i = 1 , me % n sk = atol ( i ) + rtol ( i ) * abs ( y ( i )) der2 = der2 + (( f1 ( i ) - f0 ( i )) / sk ) ** 2 end do end if der2 = sqrt ( der2 ) / h ! step size is computed such that !  h**iord * max ( norm (f0), norm (der2)) = 0.01 der12 = max ( abs ( der2 ), sqrt ( dnf )) if ( der12 <= 1.0e-15_wp ) then h1 = max ( 1.0e-6_wp , abs ( h ) * 1.0e-3_wp ) else h1 = ( 0.01_wp / der12 ) ** ( 1.0_wp / iord ) end if h = min ( 10 0.0_wp * abs ( h ), h1 , hmax ) hinit = sign ( h , posneg ) end function hinit !***************************************************************************************** !***************************************************************************************** !> !  this function can be used for continuous output in connection !  with the output-subroutine for [[dop853]]. it provides an !  approximation to the `ii`-th component of the solution at `x`. function contd8 ( me , ii , x ) result ( y ) implicit none class ( dop853_class ), intent ( in ) :: me integer , intent ( in ) :: ii real ( wp ), intent ( in ) :: x real ( wp ) :: y real ( wp ) :: conpar , s , s1 integer :: i , j , nd , ierr ! compute place of ii-th component i = 0 do j = 1 , me % nrdens if ( me % icomp ( j ) == ii ) i = j end do if ( i == 0 ) then !always report this message, since it is an invalid use of the code. if ( me % iprint == 0 ) then ierr = error_unit else ierr = me % iprint end if write ( ierr , * ) & ' Error in contd8: no dense output available for component:' , ii y = 0.0_wp else nd = me % nrdens s = ( x - me % xold ) / me % hout s1 = 1.0_wp - s conpar = me % cont ( i + nd * 4 ) + & s * ( me % cont ( i + nd * 5 ) + & s1 * ( me % cont ( i + nd * 6 ) + s * me % cont ( i + nd * 7 ))) y = me % cont ( i ) + & s * ( me % cont ( i + nd ) + & s1 * ( me % cont ( i + nd * 2 ) + & s * ( me % cont ( i + nd * 3 ) + s1 * conpar ))) end if end function contd8 !***************************************************************************************** !***************************************************************************************** end module dop853_module !*****************************************************************************************","tags":"","loc":"sourcefile/dop853_module.f90.html","title":"dop853_module.f90 – dop853"},{"text":"Source Code !***************************************************************************************** !> !  Constants used by [[dop853_module]]. ! module dop853_constants use iso_fortran_env , only : wp => real64 implicit none real ( wp ), parameter :: uround = epsilon ( 1.0_wp ) !! machine  \\epsilon  !integration constants (formerly in dp86co): real ( wp ), parameter :: c2 = 0.526001519587677318785587544488e-01_wp real ( wp ), parameter :: c3 = 0.789002279381515978178381316732e-01_wp real ( wp ), parameter :: c4 = 0.118350341907227396726757197510_wp real ( wp ), parameter :: c5 = 0.281649658092772603273242802490_wp real ( wp ), parameter :: c6 = 0.333333333333333333333333333333_wp real ( wp ), parameter :: c7 = 0.25_wp real ( wp ), parameter :: c8 = 0.307692307692307692307692307692_wp real ( wp ), parameter :: c9 = 0.651282051282051282051282051282_wp real ( wp ), parameter :: c10 = 0.6_wp real ( wp ), parameter :: c11 = 0.857142857142857142857142857142_wp real ( wp ), parameter :: c14 = 0.1_wp real ( wp ), parameter :: c15 = 0.2_wp real ( wp ), parameter :: c16 = 0.777777777777777777777777777778_wp real ( wp ), parameter :: b1 = 5.42937341165687622380535766363e-2_wp real ( wp ), parameter :: b6 = 4.45031289275240888144113950566_wp real ( wp ), parameter :: b7 = 1.89151789931450038304281599044_wp real ( wp ), parameter :: b8 = - 5.8012039600105847814672114227_wp real ( wp ), parameter :: b9 = 3.1116436695781989440891606237e-1_wp real ( wp ), parameter :: b10 = - 1.52160949662516078556178806805e-1_wp real ( wp ), parameter :: b11 = 2.01365400804030348374776537501e-1_wp real ( wp ), parameter :: b12 = 4.47106157277725905176885569043e-2_wp real ( wp ), parameter :: bhh1 = 0.244094488188976377952755905512_wp real ( wp ), parameter :: bhh2 = 0.733846688281611857341361741547_wp real ( wp ), parameter :: bhh3 = 0.220588235294117647058823529412e-1_wp real ( wp ), parameter :: er1 = 0.1312004499419488073250102996e-01_wp real ( wp ), parameter :: er6 = - 0.1225156446376204440720569753e+01_wp real ( wp ), parameter :: er7 = - 0.4957589496572501915214079952_wp real ( wp ), parameter :: er8 = 0.1664377182454986536961530415e+01_wp real ( wp ), parameter :: er9 = - 0.3503288487499736816886487290_wp real ( wp ), parameter :: er10 = 0.3341791187130174790297318841_wp real ( wp ), parameter :: er11 = 0.8192320648511571246570742613e-01_wp real ( wp ), parameter :: er12 = - 0.2235530786388629525884427845e-01_wp real ( wp ), parameter :: a21 = 5.26001519587677318785587544488e-2_wp real ( wp ), parameter :: a31 = 1.97250569845378994544595329183e-2_wp real ( wp ), parameter :: a32 = 5.91751709536136983633785987549e-2_wp real ( wp ), parameter :: a41 = 2.95875854768068491816892993775e-2_wp real ( wp ), parameter :: a43 = 8.87627564304205475450678981324e-2_wp real ( wp ), parameter :: a51 = 2.41365134159266685502369798665e-1_wp real ( wp ), parameter :: a53 = - 8.84549479328286085344864962717e-1_wp real ( wp ), parameter :: a54 = 9.24834003261792003115737966543e-1_wp real ( wp ), parameter :: a61 = 3.7037037037037037037037037037e-2_wp real ( wp ), parameter :: a64 = 1.70828608729473871279604482173e-1_wp real ( wp ), parameter :: a65 = 1.25467687566822425016691814123e-1_wp real ( wp ), parameter :: a71 = 3.7109375e-2_wp real ( wp ), parameter :: a74 = 1.70252211019544039314978060272e-1_wp real ( wp ), parameter :: a75 = 6.02165389804559606850219397283e-2_wp real ( wp ), parameter :: a76 = - 1.7578125e-2_wp real ( wp ), parameter :: a81 = 3.70920001185047927108779319836e-2_wp real ( wp ), parameter :: a84 = 1.70383925712239993810214054705e-1_wp real ( wp ), parameter :: a85 = 1.07262030446373284651809199168e-1_wp real ( wp ), parameter :: a86 = - 1.53194377486244017527936158236e-2_wp real ( wp ), parameter :: a87 = 8.27378916381402288758473766002e-3_wp real ( wp ), parameter :: a91 = 6.24110958716075717114429577812e-1_wp real ( wp ), parameter :: a94 = - 3.36089262944694129406857109825_wp real ( wp ), parameter :: a95 = - 8.68219346841726006818189891453e-1_wp real ( wp ), parameter :: a96 = 2.75920996994467083049415600797e+1_wp real ( wp ), parameter :: a97 = 2.01540675504778934086186788979e+1_wp real ( wp ), parameter :: a98 = - 4.34898841810699588477366255144e+1_wp real ( wp ), parameter :: a101 = 4.77662536438264365890433908527e-1_wp real ( wp ), parameter :: a104 = - 2.48811461997166764192642586468_wp real ( wp ), parameter :: a105 = - 5.90290826836842996371446475743e-1_wp real ( wp ), parameter :: a106 = 2.12300514481811942347288949897e+1_wp real ( wp ), parameter :: a107 = 1.52792336328824235832596922938e+1_wp real ( wp ), parameter :: a108 = - 3.32882109689848629194453265587e+1_wp real ( wp ), parameter :: a109 = - 2.03312017085086261358222928593e-2_wp real ( wp ), parameter :: a111 = - 9.3714243008598732571704021658e-1_wp real ( wp ), parameter :: a114 = 5.18637242884406370830023853209_wp real ( wp ), parameter :: a115 = 1.09143734899672957818500254654_wp real ( wp ), parameter :: a116 = - 8.14978701074692612513997267357_wp real ( wp ), parameter :: a117 = - 1.85200656599969598641566180701e+1_wp real ( wp ), parameter :: a118 = 2.27394870993505042818970056734e+1_wp real ( wp ), parameter :: a119 = 2.49360555267965238987089396762_wp real ( wp ), parameter :: a1110 = - 3.0467644718982195003823669022_wp real ( wp ), parameter :: a121 = 2.27331014751653820792359768449_wp real ( wp ), parameter :: a124 = - 1.05344954667372501984066689879e+1_wp real ( wp ), parameter :: a125 = - 2.00087205822486249909675718444_wp real ( wp ), parameter :: a126 = - 1.79589318631187989172765950534e+1_wp real ( wp ), parameter :: a127 = 2.79488845294199600508499808837e+1_wp real ( wp ), parameter :: a128 = - 2.85899827713502369474065508674_wp real ( wp ), parameter :: a129 = - 8.87285693353062954433549289258_wp real ( wp ), parameter :: a1210 = 1.23605671757943030647266201528e+1_wp real ( wp ), parameter :: a1211 = 6.43392746015763530355970484046e-1_wp real ( wp ), parameter :: a141 = 5.61675022830479523392909219681e-2_wp real ( wp ), parameter :: a147 = 2.53500210216624811088794765333e-1_wp real ( wp ), parameter :: a148 = - 2.46239037470802489917441475441e-1_wp real ( wp ), parameter :: a149 = - 1.24191423263816360469010140626e-1_wp real ( wp ), parameter :: a1410 = 1.5329179827876569731206322685e-1_wp real ( wp ), parameter :: a1411 = 8.20105229563468988491666602057e-3_wp real ( wp ), parameter :: a1412 = 7.56789766054569976138603589584e-3_wp real ( wp ), parameter :: a1413 = - 8.298e-3_wp real ( wp ), parameter :: a151 = 3.18346481635021405060768473261e-2_wp real ( wp ), parameter :: a156 = 2.83009096723667755288322961402e-2_wp real ( wp ), parameter :: a157 = 5.35419883074385676223797384372e-2_wp real ( wp ), parameter :: a158 = - 5.49237485713909884646569340306e-2_wp real ( wp ), parameter :: a1511 = - 1.08347328697249322858509316994e-4_wp real ( wp ), parameter :: a1512 = 3.82571090835658412954920192323e-4_wp real ( wp ), parameter :: a1513 = - 3.40465008687404560802977114492e-4_wp real ( wp ), parameter :: a1514 = 1.41312443674632500278074618366e-1_wp real ( wp ), parameter :: a161 = - 4.28896301583791923408573538692e-1_wp real ( wp ), parameter :: a166 = - 4.69762141536116384314449447206_wp real ( wp ), parameter :: a167 = 7.68342119606259904184240953878_wp real ( wp ), parameter :: a168 = 4.06898981839711007970213554331_wp real ( wp ), parameter :: a169 = 3.56727187455281109270669543021e-1_wp real ( wp ), parameter :: a1613 = - 1.39902416515901462129418009734e-3_wp real ( wp ), parameter :: a1614 = 2.9475147891527723389556272149_wp real ( wp ), parameter :: a1615 = - 9.15095847217987001081870187138_wp real ( wp ), parameter :: d41 = - 0.84289382761090128651353491142e+01_wp real ( wp ), parameter :: d46 = 0.56671495351937776962531783590_wp real ( wp ), parameter :: d47 = - 0.30689499459498916912797304727e+01_wp real ( wp ), parameter :: d48 = 0.23846676565120698287728149680e+01_wp real ( wp ), parameter :: d49 = 0.21170345824450282767155149946e+01_wp real ( wp ), parameter :: d410 = - 0.87139158377797299206789907490_wp real ( wp ), parameter :: d411 = 0.22404374302607882758541771650e+01_wp real ( wp ), parameter :: d412 = 0.63157877876946881815570249290_wp real ( wp ), parameter :: d413 = - 0.88990336451333310820698117400e-01_wp real ( wp ), parameter :: d414 = 0.18148505520854727256656404962e+02_wp real ( wp ), parameter :: d415 = - 0.91946323924783554000451984436e+01_wp real ( wp ), parameter :: d416 = - 0.44360363875948939664310572000e+01_wp real ( wp ), parameter :: d51 = 0.10427508642579134603413151009e+02_wp real ( wp ), parameter :: d56 = 0.24228349177525818288430175319e+03_wp real ( wp ), parameter :: d57 = 0.16520045171727028198505394887e+03_wp real ( wp ), parameter :: d58 = - 0.37454675472269020279518312152e+03_wp real ( wp ), parameter :: d59 = - 0.22113666853125306036270938578e+02_wp real ( wp ), parameter :: d510 = 0.77334326684722638389603898808e+01_wp real ( wp ), parameter :: d511 = - 0.30674084731089398182061213626e+02_wp real ( wp ), parameter :: d512 = - 0.93321305264302278729567221706e+01_wp real ( wp ), parameter :: d513 = 0.15697238121770843886131091075e+02_wp real ( wp ), parameter :: d514 = - 0.31139403219565177677282850411e+02_wp real ( wp ), parameter :: d515 = - 0.93529243588444783865713862664e+01_wp real ( wp ), parameter :: d516 = 0.35816841486394083752465898540e+02_wp real ( wp ), parameter :: d61 = 0.19985053242002433820987653617e+02_wp real ( wp ), parameter :: d66 = - 0.38703730874935176555105901742e+03_wp real ( wp ), parameter :: d67 = - 0.18917813819516756882830838328e+03_wp real ( wp ), parameter :: d68 = 0.52780815920542364900561016686e+03_wp real ( wp ), parameter :: d69 = - 0.11573902539959630126141871134e+02_wp real ( wp ), parameter :: d610 = 0.68812326946963000169666922661e+01_wp real ( wp ), parameter :: d611 = - 0.10006050966910838403183860980e+01_wp real ( wp ), parameter :: d612 = 0.77771377980534432092869265740_wp real ( wp ), parameter :: d613 = - 0.27782057523535084065932004339e+01_wp real ( wp ), parameter :: d614 = - 0.60196695231264120758267380846e+02_wp real ( wp ), parameter :: d615 = 0.84320405506677161018159903784e+02_wp real ( wp ), parameter :: d616 = 0.11992291136182789328035130030e+02_wp real ( wp ), parameter :: d71 = - 0.25693933462703749003312586129e+02_wp real ( wp ), parameter :: d76 = - 0.15418974869023643374053993627e+03_wp real ( wp ), parameter :: d77 = - 0.23152937917604549567536039109e+03_wp real ( wp ), parameter :: d78 = 0.35763911791061412378285349910e+03_wp real ( wp ), parameter :: d79 = 0.93405324183624310003907691704e+02_wp real ( wp ), parameter :: d710 = - 0.37458323136451633156875139351e+02_wp real ( wp ), parameter :: d711 = 0.10409964950896230045147246184e+03_wp real ( wp ), parameter :: d712 = 0.29840293426660503123344363579e+02_wp real ( wp ), parameter :: d713 = - 0.43533456590011143754432175058e+02_wp real ( wp ), parameter :: d714 = 0.96324553959188282948394950600e+02_wp real ( wp ), parameter :: d715 = - 0.39177261675615439165231486172e+02_wp real ( wp ), parameter :: d716 = - 0.14972683625798562581422125276e+03_wp end module dop853_constants !*****************************************************************************************","tags":"","loc":"sourcefile/dop853_constants.f90.html","title":"dop853_constants.f90 – dop853"},{"text":"Source Code !***************************************************************************************** !> !  Driver for [[dop853]] on van der Pol's equation. ! !### See also !  * Based on [dr_dop853.f](http://www.unige.ch/~hairer/prog/nonstiff/dr_dop853.f) ! !### Results !  ![Forward Test](|media|/dop853_forward.png) !  ![Backward Test](|media|/dop853_backward.png) ! !@note This requires [pyplot-fortran](https://github.com/jacobwilliams/pyplot-fortran). program dop853_test use dop853_module use dop853_constants use iso_fortran_env , only : output_unit use pyplot_module implicit none integer , parameter :: n = 2 !! dimension of the system integer , dimension ( n ), parameter :: icomp = [ 1 , 2 ] !! indices of `y` where we need dense output integer , parameter :: iout = 3 !! output routine (and dense output) is used during integration real ( wp ), parameter :: tol = 1.0e-12_wp !! required (relative) tolerance real ( wp ), parameter :: x0 = 0.0_wp !! initial `x` value real ( wp ), parameter :: xf = 10 0.0_wp !! endpoint of integration real ( wp ), dimension ( n ), parameter :: y0 = [ 0.0_wp , 0.1_wp ] !! initial `y` value real ( wp ), parameter :: dx = 0.01_wp !! time step for dense output logical , parameter :: make_plots = . true . !! use pyplot to generate plots. type ( dop853_class ) :: prop real ( wp ), dimension ( n ) :: y real ( wp ), dimension ( 1 ) :: rtol , atol real ( wp ) :: x , xend integer :: i , idid , j , nfcn , nstep , naccpt , nrejct logical :: status_ok type ( pyplot ) :: plt real ( wp ), dimension (:), allocatable :: t_vec , y_vec , yp_vec x = x0 y = y0 xend = xf rtol = tol atol = tol call prop % initialize ( fcn = fvpol , & n = n , & solout = solout , & icomp = icomp , & nstiff = 1 , & status_ok = status_ok ) !all other parameters use defaults if ( status_ok ) then call prop % integrate ( x , y , xend , rtol , atol , iout , idid ) call prop % info ( nfcn , nstep , naccpt , nrejct ) if ( make_plots ) then t_vec = [ t_vec , x ] !last point y_vec = [ y_vec , y ( 1 )] yp_vec = [ yp_vec , y ( 2 )] end if ! print final solution write ( output_unit , '(1X,A,F6.2,A,2E18.10)' ) & 'x =' , x , '    y =' , y ( 1 ), y ( 2 ) ! print statistics write ( output_unit , '(A,D8.2)' ) '       tol=' , tol write ( output_unit , '(A,I5,A,I4,A,I4,A,I3)' ) & ' fcn=' , nfcn , ' step=' , nstep , ' accpt=' , naccpt , ' rejct=' , nrejct ! plot: if ( make_plots ) then call plt % initialize ( grid = . true ., xlabel = 'y(x)' ,& ylabel = 'y''(x)' ,& title = 'van der Pol''s Equation ($\\mu = 0.2$)' , legend = . true .) call plt % add_plot ( y_vec , yp_vec , label = 'Forward' ,& linestyle = 'r-' , linewidth = 2 ,& xlim = [ - 3.0_wp , 3.0_wp ], ylim = [ - 3.0_wp , 3.0_wp ]) call plt % savefig ( 'dop853_forward.png' ) call plt % destroy () deallocate ( t_vec ) deallocate ( y_vec ) deallocate ( yp_vec ) end if !-------------------------------------------------- write ( * , * ) '' write ( * , * ) 'backwards test' write ( * , * ) '' call prop % destroy () call prop % initialize ( fcn = fvpol , n = n , solout = solout2 , status_ok = status_ok ) call prop % integrate ( x , y , x0 , rtol , atol , iout = 1 , idid = idid ) write ( * , * ) '' write ( * , * ) 'error:' , norm2 ( y - y0 ) write ( * , * ) '' ! plot: if ( make_plots ) then call plt % initialize ( grid = . true ., xlabel = 'y(x)' ,& ylabel = 'y''(x)' ,& title = 'van der Pol''s Equation ($\\mu = 0.2$)' , legend = . true .) call plt % add_plot ( y_vec , yp_vec , label = 'Backward' ,& linestyle = 'r-' , linewidth = 2 ,& xlim = [ - 3.0_wp , 3.0_wp ], ylim = [ - 3.0_wp , 3.0_wp ]) call plt % savefig ( 'dop853_backward.png' ) call plt % destroy () end if else write ( output_unit , '(A)' ) 'error calling INITIALIZE.' end if contains !***************************************************************************************** !******************************************************************************* !> !  Prints solution at equidistant output-points !  by using [[contd8]], the continuous collocation solution. !  This is for an `iout=3` case. ! !@note This routine uses Fortran 2008 LHS automatic allocations. subroutine solout ( me , nr , xold , x , y , irtrn , xout ) implicit none class ( dop853_class ), intent ( inout ) :: me integer , intent ( in ) :: nr real ( wp ), intent ( in ) :: xold real ( wp ), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y integer , intent ( inout ) :: irtrn real ( wp ), intent ( out ) :: xout !! the point where we want the next output reported if ( nr == 1 ) then write ( output_unit , '(1X,A,F6.2,A,2E18.10,A,I4)' ) & 'x =' , x ,& '    y =' , y ( 1 ), y ( 2 ),& '    nstep =' , nr - 1 xout = dx else do if ( x < xout ) exit write ( output_unit , '(1X,A,F6.2,A,2E18.10,A,I4)' ) & 'x =' , xout ,& '    y =' ,& prop % contd8 ( 1 , xout ),& prop % contd8 ( 2 , xout ),& '    nstep =' , nr - 1 xout = xout + dx end do end if if ( make_plots ) then if ( allocated ( t_vec )) then !fortran 2008 lhs allocations t_vec = [ t_vec , x ] y_vec = [ y_vec , y ( 1 )] yp_vec = [ yp_vec , y ( 2 )] else t_vec = [ x ] y_vec = [ y ( 1 )] yp_vec = [ y ( 2 )] end if end if end subroutine solout !******************************************************************************* !******************************************************************************* !> !  Prints a normal step from [[dop853]] (for `iout=1`). ! !@note This routine uses Fortran 2008 LHS automatic allocations. subroutine solout2 ( me , nr , xold , x , y , irtrn , xout ) implicit none class ( dop853_class ), intent ( inout ) :: me integer , intent ( in ) :: nr real ( wp ), intent ( in ) :: xold real ( wp ), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y integer , intent ( inout ) :: irtrn real ( wp ), intent ( out ) :: xout !! not used for `iout=1`. write ( output_unit , '(1X,A,F6.2,A,2E18.10,A,I4)' ) & 'x =' , x ,& '    y =' , y ( 1 ), y ( 2 ),& '    nstep =' , nr - 1 if ( make_plots ) then if ( allocated ( t_vec )) then t_vec = [ t_vec , x ] y_vec = [ y_vec , y ( 1 )] yp_vec = [ yp_vec , y ( 2 )] else t_vec = [ x ] y_vec = [ y ( 1 )] yp_vec = [ y ( 2 )] end if end if end subroutine solout2 !******************************************************************************* !******************************************************************************* !> ! Right-hand side of van der Pol's equation: !  y'' = \\mu(1-y&#94;2)y' - y . ! !### Reference ! * Weisstein, Eric W. \"[van der Pol Equation](http://mathworld.wolfram.com/vanderPolEquation.html).\" !   From MathWorld--A Wolfram Web Resource. ! !@note The [original code](http://www.unige.ch/~hairer/prog/nonstiff/dr_dop853.f) !      had a slightly different equation. subroutine fvpol ( me , x , y , f ) implicit none class ( dop853_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y !!  [y, y' ]  real ( wp ), dimension (:), intent ( out ) :: f !!  [y', y'' ]  real ( wp ), parameter :: mu = 0.2_wp !!  \\mu  in van der Pol's equation. f ( 1 ) = y ( 2 ) f ( 2 ) = mu * ( 1.0_wp - y ( 1 ) ** 2 ) * y ( 2 ) - y ( 1 ) end subroutine fvpol !******************************************************************************* end program dop853_test !*****************************************************************************************","tags":"","loc":"sourcefile/dop853_test.f90.html","title":"dop853_test.f90 – dop853"},{"text":"type, public :: dop853_class Components Type Visibility Attributes Name Initial integer, private :: n = 0 the dimension of the system integer, private :: nfcn = 0 number of function evaluations integer, private :: nstep = 0 number of computed steps integer, private :: naccpt = 0 number of accepted steps integer, private :: nrejct = 0 number of rejected steps (due to error test),\n (step rejections in the first step are not counted) integer, private :: nrdens = 0 number of components, for which dense output\n is required. for 0 < nrdens < n the components\n (for which dense output is required) have to be\n specified in icomp(1),...,icomp(nrdens) . real(kind=wp), private :: h = 0.0_wp predicted step size of the last accepted step integer, private :: iprint = output_unit switch for printing error messages\n if iprint==0 no messages are being printed\n if iprint/=0 messages are printed with write (iprint,*) ... integer, private :: nmax = 100000 the maximal number of allowed steps. integer, private :: nstiff = 1000 test for stiffness is activated after step number j*nstiff ( j integer), provided nstiff>0 .\n for negative nstiff the stiffness test is\n never activated. real(kind=wp), private :: hinitial = 0.0_wp initial step size, for hinitial=0 an initial guess\n is computed with help of the function hinit . real(kind=wp), private :: hmax = 0.0_wp maximal step size, defaults to xend-x if hmax=0 . real(kind=wp), private :: safe = 0.9_wp safety factor in step size prediction real(kind=wp), private :: fac1 = 0.333_wp parameter for step size selection.\n the new step size is chosen subject to the restriction fac1 <= hnew/hold <= fac2 real(kind=wp), private :: fac2 = 6.0_wp parameter for step size selection.\n the new step size is chosen subject to the restriction fac1 <= hnew/hold <= fac2 real(kind=wp), private :: beta = 0.0_wp is the beta for stabilized step size control\n (see section iv.2). positive values of beta ( <= 0.04 )\n make the step size control more stable. integer, private, dimension(:), allocatable :: icomp dimension(nrdens) the components for which dense output is required real(kind=wp), private, dimension(:), allocatable :: cont dimension(8*nrdens) real(kind=wp), private :: xold = 0.0_wp real(kind=wp), private :: hout = 0.0_wp procedure( deriv_func ), private, pointer :: fcn => null() subroutine computing the value of f(x,y) procedure( solout_func ), private, pointer :: solout => null() subroutine providing the\n numerical solution during integration.\n if iout>=1 , it is called during integration. Type-Bound Procedures procedure, public :: initialize => set_parameters initialization routine. public subroutine set_parameters (me, n, fcn, solout, iprint, nstiff, nmax, hinitial, hmax, safe, fac1, fac2, beta, icomp, status_ok) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(inout) :: me integer, intent(in) :: n the dimension of the system (size of y and y' vectors) procedure( deriv_func ) :: fcn subroutine computing the value of  y' = f(x,y)  procedure( solout_func ) , optional :: solout subroutine providing the\n numerical solution during integration.\n if iout>=1 , it is called during integration.\n supply a dummy subroutine if iout=0 . integer, intent(in), optional :: iprint switch for printing error messages\n if iprint==0 no messages are being printed\n if iprint/=0 messages are printed with write (iprint,*) ... integer, intent(in), optional :: nstiff test for stiffness is activated after step number j*nstiff ( j integer), provided nstiff>0 .\n for negative nstiff the stiffness test is\n never activated. integer, intent(in), optional :: nmax the maximal number of allowed steps. real(kind=wp), intent(in), optional :: hinitial initial step size, for hinitial=0 an initial guess\n is computed with help of the function hinit . real(kind=wp), intent(in), optional :: hmax maximal step size, defaults to xend-x if hmax=0 . real(kind=wp), intent(in), optional :: safe safety factor in step size prediction real(kind=wp), intent(in), optional :: fac1 parameter for step size selection.\n the new step size is chosen subject to the restriction fac1 <= hnew/hold <= fac2 real(kind=wp), intent(in), optional :: fac2 parameter for step size selection.\n the new step size is chosen subject to the restriction fac1 <= hnew/hold <= fac2 real(kind=wp), intent(in), optional :: beta is the beta for stabilized step size control\n (see section iv.2). positive values of beta ( <= 0.04 )\n make the step size control more stable. integer, intent(in), optional dimension(:) :: icomp the components for which dense output is required (size from 0 to n ). logical, intent(out) :: status_ok will be false for invalid inputs. Description Set the optional inputs for dop853 . procedure, public :: integrate => dop853 main integration routine. public subroutine dop853 (me, x, y, xend, rtol, atol, iout, idid) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(inout) :: me real(kind=wp), intent(inout) :: x input: initial value of independent variable. output: x for which the solution has been computed\n (after successful return x=xend ). real(kind=wp), intent(inout), dimension(:) :: y input: initial values for y . [size n] output: numerical solution at x . real(kind=wp), intent(in) :: xend final x-value (xend-x may be positive or negative) real(kind=wp), intent(in), dimension(:) :: rtol relative error tolerance. rtol and atol can be both scalars or else both vectors of length n . real(kind=wp), intent(in), dimension(:) :: atol absolute error tolerance. rtol and atol can be both scalars or else both vectors of length n . atol should be strictly positive (possibly very small) integer, intent(in) :: iout switch for calling the subroutine solout : iout=0 : subroutine is never called iout=1 : subroutine is called after every successful step iout=2 : dense output is performed after every successful step iout=3 : dense output is performed in steps defined by the user\n          (see xout above) integer, intent(out) :: idid reports on successfulness upon return: idid=1 computation successful, idid=2 comput. successful (interrupted by solout ), idid=-1 input is not consistent, idid=-2 larger nmax is needed, idid=-3 step size becomes too small. idid=-4 problem is probably stiff (interrupted). Description Numerical solution of a system of first order\n  ordinary differential equations  y'=f(x,y) .\n  This is an explicit Runge-Kutta method of order 8(5,3)\n  due to Dormand & Prince (with stepsize control and\n  dense output). procedure, public :: destroy => destroy_dop853 destructor. public subroutine destroy_dop853 (me) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(out) :: me Description Destructor for dop853_class . procedure, public :: info => get_dop853_info to get info after a run. public subroutine get_dop853_info (me, n, nfcn, nstep, naccpt, nrejct, h) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(in) :: me integer, intent(out), optional :: n dimension of the system integer, intent(out), optional :: nfcn number of function evaluations integer, intent(out), optional :: nstep number of computed steps integer, intent(out), optional :: naccpt number of accepted steps integer, intent(out), optional :: nrejct number of rejected steps (due to error test),\n (step rejections in the first step are not counted) real(kind=wp), intent(out), optional :: h predicted step size of the last accepted step Description Get info from a dop853_class . procedure, private :: dp86co public subroutine dp86co (me, x, y, xend, hmax, h, rtol, atol, itol, iprint, iout, idid, nmax, nstiff, safe, beta, fac1, fac2, nfcn, nstep, naccpt, nrejct) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(inout) :: me real(kind=wp), intent(inout) :: x real(kind=wp), intent(inout), dimension(:) :: y real(kind=wp), intent(in) :: xend real(kind=wp), intent(inout) :: hmax real(kind=wp), intent(inout) :: h real(kind=wp), intent(in), dimension(:) :: rtol real(kind=wp), intent(in), dimension(:) :: atol integer, intent(in) :: itol integer, intent(in) :: iprint integer, intent(in) :: iout integer, intent(out) :: idid integer, intent(in) :: nmax integer, intent(in) :: nstiff real(kind=wp), intent(in) :: safe real(kind=wp), intent(in) :: beta real(kind=wp), intent(in) :: fac1 real(kind=wp), intent(in) :: fac2 integer, intent(inout) :: nfcn integer, intent(inout) :: nstep integer, intent(inout) :: naccpt integer, intent(inout) :: nrejct Description Core integrator for dop853 .\n  parameters same as in dop853 with workspace added. procedure, private :: hinit public function hinit (me, x, y, posneg, f0, iord, hmax, atol, rtol, itol) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in), dimension(:) :: y dimension(n) real(kind=wp), intent(in) :: posneg real(kind=wp), intent(in), dimension(:) :: f0 dimension(n) integer, intent(in) :: iord real(kind=wp), intent(in) :: hmax real(kind=wp), intent(in), dimension(:) :: atol real(kind=wp), intent(in), dimension(:) :: rtol integer, intent(in) :: itol Return Value real(kind=wp) Description computation of an initial step size guess procedure, public :: contd8 can be called in user's solout_func for dense output. public function contd8 (me, ii, x) result(y) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(in) :: me integer, intent(in) :: ii real(kind=wp), intent(in) :: x Return Value real(kind=wp) Description this function can be used for continuous output in connection\n  with the output-subroutine for dop853 . it provides an\n  approximation to the ii -th component of the solution at x . Source Code type , public :: dop853_class private !internal variables: integer :: n = 0 !! the dimension of the system integer :: nfcn = 0 !! number of function evaluations integer :: nstep = 0 !! number of computed steps integer :: naccpt = 0 !! number of accepted steps integer :: nrejct = 0 !! number of rejected steps (due to error test), !! (step rejections in the first step are not counted) integer :: nrdens = 0 !! number of components, for which dense output !! is required. for `0 < nrdens < n` the components !! (for which dense output is required) have to be !! specified in `icomp(1),...,icomp(nrdens)`. real ( wp ) :: h = 0.0_wp !! predicted step size of the last accepted step !input paramters: !  these parameters allow !  to adapt the code to the problem and to the needs of !  the user. set them on class initialization. integer :: iprint = output_unit !! switch for printing error messages !! if `iprint==0` no messages are being printed !! if `iprint/=0` messages are printed with !! `write (iprint,*)` ... integer :: nmax = 100000 !! the maximal number of allowed steps. integer :: nstiff = 1000 !! test for stiffness is activated after step number !! `j*nstiff` (`j` integer), provided `nstiff>0`. !! for negative `nstiff` the stiffness test is !! never activated. real ( wp ) :: hinitial = 0.0_wp !! initial step size, for `hinitial=0` an initial guess !! is computed with help of the function [[hinit]]. real ( wp ) :: hmax = 0.0_wp !! maximal step size, defaults to `xend-x` if `hmax=0`. real ( wp ) :: safe = 0.9_wp !! safety factor in step size prediction real ( wp ) :: fac1 = 0.333_wp !! parameter for step size selection. !! the new step size is chosen subject to the restriction !! `fac1 <= hnew/hold <= fac2` real ( wp ) :: fac2 = 6.0_wp !! parameter for step size selection. !! the new step size is chosen subject to the restriction !! `fac1 <= hnew/hold <= fac2` real ( wp ) :: beta = 0.0_wp !! is the `beta` for stabilized step size control !! (see section iv.2). positive values of beta ( <= 0.04 ) !! make the step size control more stable. integer , dimension (:), allocatable :: icomp !! `dimension(nrdens)` !! the components for which dense output is required real ( wp ), dimension (:), allocatable :: cont !! `dimension(8*nrdens)` !formerly in the condo8 common block: real ( wp ) :: xold = 0.0_wp real ( wp ) :: hout = 0.0_wp !user-defined procedures: procedure ( deriv_func ), pointer :: fcn => null () !! subroutine computing the value of `f(x,y)` procedure ( solout_func ), pointer :: solout => null () !! subroutine providing the !! numerical solution during integration. !! if `iout>=1`, it is called during integration. contains private procedure , public :: initialize => set_parameters !! initialization routine. procedure , public :: integrate => dop853 !! main integration routine. procedure , public :: destroy => destroy_dop853 !! destructor. procedure , public :: info => get_dop853_info !! to get info after a run. procedure :: dp86co procedure :: hinit procedure , public :: contd8 !! can be called in user's [[solout_func]] for dense output. end type dop853_class","tags":"","loc":"type/dop853_class.html","title":"dop853_class – dop853 "},{"text":"abstract interface public subroutine deriv_func(me, x, y, f) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(inout) :: me real(kind=wp), intent(in) :: x independent variable x real(kind=wp), intent(in), dimension(:) :: y state vector  y(x)  [size n] real(kind=wp), intent(out), dimension(:) :: f derivative vector  f(x,y) = dy/dx  [size n] Description subroutine computing the value of  dy/dx = f(x,y) ","tags":"","loc":"interface/deriv_func.html","title":"deriv_func – dop853"},{"text":"abstract interface public subroutine solout_func(me, nr, xold, x, y, irtrn, xout) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(inout) :: me integer, intent(in) :: nr grid point (0,1,...) real(kind=wp), intent(in) :: xold the preceeding grid point real(kind=wp), intent(in) :: x current grid point real(kind=wp), intent(in), dimension(:) :: y state vector  y(x)  [size n] integer, intent(inout) :: irtrn serves to interrupt the integration. if irtrn is set <0 , dop853 will return to\n the calling program. if the numerical solution\n is altered in solout , set irtrn = 2 . real(kind=wp), intent(out) :: xout xout can be used for efficient intermediate output\n if one puts iout=3 . when nr=1 define the first\n output point xout in solout . the subroutine solout will be called only when xout is in the\n interval [xold,x] ; during this call\n a new value for xout can be defined, etc. Description solout furnishes the solution y at the nr -th\n grid-point x (thereby the initial value is\n the first grid-point).","tags":"","loc":"interface/solout_func.html","title":"solout_func – dop853"},{"text":"public function hinit(me, x, y, posneg, f0, iord, hmax, atol, rtol, itol) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in), dimension(:) :: y dimension(n) real(kind=wp), intent(in) :: posneg real(kind=wp), intent(in), dimension(:) :: f0 dimension(n) integer, intent(in) :: iord real(kind=wp), intent(in) :: hmax real(kind=wp), intent(in), dimension(:) :: atol real(kind=wp), intent(in), dimension(:) :: rtol integer, intent(in) :: itol Return Value real(kind=wp) Description computation of an initial step size guess Variables Type Visibility Attributes Name Initial real(kind=wp), public :: atoli real(kind=wp), public :: der12 real(kind=wp), public :: der2 real(kind=wp), public :: dnf real(kind=wp), public :: dny real(kind=wp), public :: h real(kind=wp), public :: h1 real(kind=wp), public :: rtoli real(kind=wp), public :: sk integer, public :: i real(kind=wp), public, dimension(me%n) :: f1 real(kind=wp), public, dimension(me%n) :: y1 Source Code function hinit ( me , x , y , posneg , f0 , iord , hmax , atol , rtol , itol ) implicit none class ( dop853_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y !! dimension(n) real ( wp ), intent ( in ) :: posneg real ( wp ), dimension (:), intent ( in ) :: f0 !! dimension(n) integer , intent ( in ) :: iord real ( wp ), intent ( in ) :: hmax real ( wp ), dimension (:), intent ( in ) :: atol real ( wp ), dimension (:), intent ( in ) :: rtol integer , intent ( in ) :: itol real ( wp ) :: atoli , der12 , der2 , dnf , dny , h , h1 , hinit , rtoli , sk integer :: i real ( wp ), dimension ( me % n ) :: f1 , y1 ! compute a first guess for explicit euler as !   h = 0.01 * norm (y0) / norm (f0) ! the increment for explicit euler is small ! compared to the solution dnf = 0.0_wp dny = 0.0_wp atoli = atol ( 1 ) rtoli = rtol ( 1 ) if ( itol == 0 ) then do i = 1 , me % n sk = atoli + rtoli * abs ( y ( i )) dnf = dnf + ( f0 ( i ) / sk ) ** 2 dny = dny + ( y ( i ) / sk ) ** 2 end do else do i = 1 , me % n sk = atol ( i ) + rtol ( i ) * abs ( y ( i )) dnf = dnf + ( f0 ( i ) / sk ) ** 2 dny = dny + ( y ( i ) / sk ) ** 2 end do end if if ( dnf <= 1.0e-10_wp . or . dny <= 1.0e-10_wp ) then h = 1.0e-6_wp else h = sqrt ( dny / dnf ) * 0.01_wp end if h = min ( h , hmax ) h = sign ( h , posneg ) ! perform an explicit euler step do i = 1 , me % n y1 ( i ) = y ( i ) + h * f0 ( i ) end do call me % fcn ( x + h , y1 , f1 ) ! estimate the second derivative of the solution der2 = 0.0_wp if ( itol == 0 ) then do i = 1 , me % n sk = atoli + rtoli * abs ( y ( i )) der2 = der2 + (( f1 ( i ) - f0 ( i )) / sk ) ** 2 end do else do i = 1 , me % n sk = atol ( i ) + rtol ( i ) * abs ( y ( i )) der2 = der2 + (( f1 ( i ) - f0 ( i )) / sk ) ** 2 end do end if der2 = sqrt ( der2 ) / h ! step size is computed such that !  h**iord * max ( norm (f0), norm (der2)) = 0.01 der12 = max ( abs ( der2 ), sqrt ( dnf )) if ( der12 <= 1.0e-15_wp ) then h1 = max ( 1.0e-6_wp , abs ( h ) * 1.0e-3_wp ) else h1 = ( 0.01_wp / der12 ) ** ( 1.0_wp / iord ) end if h = min ( 10 0.0_wp * abs ( h ), h1 , hmax ) hinit = sign ( h , posneg ) end function hinit","tags":"","loc":"proc/hinit.html","title":"hinit – dop853"},{"text":"public function contd8(me, ii, x) result(y) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(in) :: me integer, intent(in) :: ii real(kind=wp), intent(in) :: x Return Value real(kind=wp) Description this function can be used for continuous output in connection\n  with the output-subroutine for dop853 . it provides an\n  approximation to the ii -th component of the solution at x . Variables Type Visibility Attributes Name Initial real(kind=wp), public :: conpar real(kind=wp), public :: s real(kind=wp), public :: s1 integer, public :: i integer, public :: j integer, public :: nd integer, public :: ierr Source Code function contd8 ( me , ii , x ) result ( y ) implicit none class ( dop853_class ), intent ( in ) :: me integer , intent ( in ) :: ii real ( wp ), intent ( in ) :: x real ( wp ) :: y real ( wp ) :: conpar , s , s1 integer :: i , j , nd , ierr ! compute place of ii-th component i = 0 do j = 1 , me % nrdens if ( me % icomp ( j ) == ii ) i = j end do if ( i == 0 ) then !always report this message, since it is an invalid use of the code. if ( me % iprint == 0 ) then ierr = error_unit else ierr = me % iprint end if write ( ierr , * ) & ' Error in contd8: no dense output available for component:' , ii y = 0.0_wp else nd = me % nrdens s = ( x - me % xold ) / me % hout s1 = 1.0_wp - s conpar = me % cont ( i + nd * 4 ) + & s * ( me % cont ( i + nd * 5 ) + & s1 * ( me % cont ( i + nd * 6 ) + s * me % cont ( i + nd * 7 ))) y = me % cont ( i ) + & s * ( me % cont ( i + nd ) + & s1 * ( me % cont ( i + nd * 2 ) + & s * ( me % cont ( i + nd * 3 ) + s1 * conpar ))) end if end function contd8","tags":"","loc":"proc/contd8.html","title":"contd8 – dop853"},{"text":"public subroutine get_dop853_info(me, n, nfcn, nstep, naccpt, nrejct, h) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(in) :: me integer, intent(out), optional :: n dimension of the system integer, intent(out), optional :: nfcn number of function evaluations integer, intent(out), optional :: nstep number of computed steps integer, intent(out), optional :: naccpt number of accepted steps integer, intent(out), optional :: nrejct number of rejected steps (due to error test),\n (step rejections in the first step are not counted) real(kind=wp), intent(out), optional :: h predicted step size of the last accepted step Description Get info from a dop853_class . Source Code subroutine get_dop853_info ( me , n , nfcn , nstep , naccpt , nrejct , h ) implicit none class ( dop853_class ), intent ( in ) :: me integer , intent ( out ), optional :: n !! dimension of the system integer , intent ( out ), optional :: nfcn !! number of function evaluations integer , intent ( out ), optional :: nstep !! number of computed steps integer , intent ( out ), optional :: naccpt !! number of accepted steps integer , intent ( out ), optional :: nrejct !! number of rejected steps (due to error test), !! (step rejections in the first step are not counted) real ( wp ), intent ( out ), optional :: h !! predicted step size of the last accepted step if ( present ( n )) n = me % n if ( present ( nfcn )) nfcn = me % nfcn if ( present ( nstep )) nstep = me % nstep if ( present ( naccpt )) naccpt = me % naccpt if ( present ( nrejct )) nrejct = me % nrejct if ( present ( h )) h = me % h end subroutine get_dop853_info","tags":"","loc":"proc/get_dop853_info.html","title":"get_dop853_info – dop853"},{"text":"public subroutine destroy_dop853(me) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(out) :: me Description Destructor for dop853_class . Source Code subroutine destroy_dop853 ( me ) implicit none class ( dop853_class ), intent ( out ) :: me end subroutine destroy_dop853","tags":"","loc":"proc/destroy_dop853.html","title":"destroy_dop853 – dop853"},{"text":"public subroutine set_parameters(me, n, fcn, solout, iprint, nstiff, nmax, hinitial, hmax, safe, fac1, fac2, beta, icomp, status_ok) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(inout) :: me integer, intent(in) :: n the dimension of the system (size of y and y' vectors) procedure( deriv_func ) :: fcn subroutine computing the value of  y' = f(x,y)  procedure( solout_func ) , optional :: solout subroutine providing the\n numerical solution during integration.\n if iout>=1 , it is called during integration.\n supply a dummy subroutine if iout=0 . integer, intent(in), optional :: iprint switch for printing error messages\n if iprint==0 no messages are being printed\n if iprint/=0 messages are printed with write (iprint,*) ... integer, intent(in), optional :: nstiff test for stiffness is activated after step number j*nstiff ( j integer), provided nstiff>0 .\n for negative nstiff the stiffness test is\n never activated. integer, intent(in), optional :: nmax the maximal number of allowed steps. real(kind=wp), intent(in), optional :: hinitial initial step size, for hinitial=0 an initial guess\n is computed with help of the function hinit . real(kind=wp), intent(in), optional :: hmax maximal step size, defaults to xend-x if hmax=0 . real(kind=wp), intent(in), optional :: safe safety factor in step size prediction real(kind=wp), intent(in), optional :: fac1 parameter for step size selection.\n the new step size is chosen subject to the restriction fac1 <= hnew/hold <= fac2 real(kind=wp), intent(in), optional :: fac2 parameter for step size selection.\n the new step size is chosen subject to the restriction fac1 <= hnew/hold <= fac2 real(kind=wp), intent(in), optional :: beta is the beta for stabilized step size control\n (see section iv.2). positive values of beta ( <= 0.04 )\n make the step size control more stable. integer, intent(in), optional dimension(:) :: icomp the components for which dense output is required (size from 0 to n ). logical, intent(out) :: status_ok will be false for invalid inputs. Description Set the optional inputs for dop853 . Note In the original code, these were part of the work and iwork arrays. Source Code subroutine set_parameters ( me , n , fcn , solout , iprint , nstiff , nmax , hinitial ,& hmax , safe , fac1 , fac2 , beta , icomp , status_ok ) implicit none class ( dop853_class ), intent ( inout ) :: me integer , intent ( in ) :: n !! the dimension of the system (size of y and y' vectors) procedure ( deriv_func ) :: fcn !! subroutine computing the value of  y' = f(x,y)  procedure ( solout_func ), optional :: solout !! subroutine providing the !! numerical solution during integration. !! if `iout>=1`, it is called during integration. !! supply a dummy subroutine if `iout=0`. integer , intent ( in ), optional :: iprint !! switch for printing error messages !! if `iprint==0` no messages are being printed !! if `iprint/=0` messages are printed with !! `write (iprint,*)` ... integer , intent ( in ), optional :: nstiff !! test for stiffness is activated after step number !! `j*nstiff` (`j` integer), provided `nstiff>0`. !! for negative `nstiff` the stiffness test is !! never activated. integer , intent ( in ), optional :: nmax !! the maximal number of allowed steps. real ( wp ), intent ( in ), optional :: hinitial !! initial step size, for `hinitial=0` an initial guess !! is computed with help of the function [[hinit]]. real ( wp ), intent ( in ), optional :: hmax !! maximal step size, defaults to `xend-x` if `hmax=0`. real ( wp ), intent ( in ), optional :: safe !! safety factor in step size prediction real ( wp ), intent ( in ), optional :: fac1 !! parameter for step size selection. !! the new step size is chosen subject to the restriction !! `fac1 <= hnew/hold <= fac2` real ( wp ), intent ( in ), optional :: fac2 !! parameter for step size selection. !! the new step size is chosen subject to the restriction !! `fac1 <= hnew/hold <= fac2` real ( wp ), intent ( in ), optional :: beta !! is the `beta` for stabilized step size control !! (see section iv.2). positive values of `beta` ( <= 0.04 ) !! make the step size control more stable. integer , dimension (:), intent ( in ), optional :: icomp !! the components for which dense output is required (size from 0 to `n`). logical , intent ( out ) :: status_ok !! will be false for invalid inputs. call me % destroy () status_ok = . true . !required inputs: me % n = n me % fcn => fcn !optional inputs: if ( present ( solout )) me % solout => solout if ( present ( iprint )) me % iprint = iprint if ( present ( nstiff )) me % nstiff = nstiff if ( present ( hinitial )) me % hinitial = hinitial if ( present ( hmax )) me % hmax = hmax if ( present ( fac1 )) me % fac1 = fac1 if ( present ( fac2 )) me % fac2 = fac2 if ( present ( nmax )) then if ( nmax <= 0 ) then if ( me % iprint /= 0 ) & write ( me % iprint , * ) ' wrong input nmax=' , nmax status_ok = . false . else me % nmax = nmax end if end if if ( present ( safe )) then if ( safe >= 1.0_wp . or . safe <= 1.0e-4_wp ) then if ( me % iprint /= 0 ) & write ( me % iprint , * ) ' curious input for safety factor safe:' , & safe status_ok = . false . else me % safe = safe end if end if if ( present ( beta )) then if ( beta <= 0.0_wp ) then me % beta = 0.0_wp else if ( beta > 0.2_wp ) then if ( me % iprint /= 0 ) write ( me % iprint , * ) & ' curious input for beta: ' , beta status_ok = . false . else me % beta = beta end if end if end if if ( present ( icomp )) then me % nrdens = size ( icomp ) !check validity of icomp array: if ( size ( icomp ) <= me % n . and . all ( icomp > 0 . and . icomp <= me % n )) then allocate ( me % icomp ( me % nrdens )); me % icomp = icomp allocate ( me % cont ( 8 * me % nrdens )); me % cont = 0.0_wp else if ( me % iprint /= 0 ) write ( me % iprint , * ) & ' invalid icomp array: ' , icomp status_ok = . false . end if end if end subroutine set_parameters","tags":"","loc":"proc/set_parameters.html","title":"set_parameters – dop853"},{"text":"public subroutine dop853(me, x, y, xend, rtol, atol, iout, idid) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(inout) :: me real(kind=wp), intent(inout) :: x input: initial value of independent variable. output: x for which the solution has been computed\n (after successful return x=xend ). real(kind=wp), intent(inout), dimension(:) :: y input: initial values for y . [size n] output: numerical solution at x . real(kind=wp), intent(in) :: xend final x-value (xend-x may be positive or negative) real(kind=wp), intent(in), dimension(:) :: rtol relative error tolerance. rtol and atol can be both scalars or else both vectors of length n . real(kind=wp), intent(in), dimension(:) :: atol absolute error tolerance. rtol and atol can be both scalars or else both vectors of length n . atol should be strictly positive (possibly very small) integer, intent(in) :: iout switch for calling the subroutine solout : iout=0 : subroutine is never called iout=1 : subroutine is called after every successful step iout=2 : dense output is performed after every successful step iout=3 : dense output is performed in steps defined by the user\n          (see xout above) integer, intent(out) :: idid reports on successfulness upon return: idid=1 computation successful, idid=2 comput. successful (interrupted by solout ), idid=-1 input is not consistent, idid=-2 larger nmax is needed, idid=-3 step size becomes too small. idid=-4 problem is probably stiff (interrupted). Description Numerical solution of a system of first order\n  ordinary differential equations  y'=f(x,y) .\n  This is an explicit Runge-Kutta method of order 8(5,3)\n  due to Dormand & Prince (with stepsize control and\n  dense output). Authors E. Hairer and G. Wanner\n    Universite de Geneve, Dept. De Mathematiques\n    ch-1211 geneve 24, switzerland\n    e-mail:  ernst.hairer@unige.ch\n             gerhard.wanner@unige.ch Version of October 11, 2009\n    (new option iout=3 for sparse dense output) Jacob Williams, Dec 2015: significant refactoring into modern Fortran. Reference E. Hairer, S.P. Norsett and G. Wanner, Solving Ordinary\n    Differential Equations I. Nonstiff Problems. 2nd Edition .\n    Springer Series in Computational Mathematics, Springer-Verlag (1993) Variables Type Visibility Attributes Name Initial real(kind=wp), public :: beta real(kind=wp), public :: fac1 real(kind=wp), public :: fac2 real(kind=wp), public :: h real(kind=wp), public :: hmax real(kind=wp), public :: safe integer, public :: i integer, public :: ieco integer, public :: iprint integer, public :: istore integer, public :: nrdens integer, public :: nstiff integer, public :: nmax logical, public :: arret integer, public :: itol switch for rtol and atol : itol=0 : both rtol and atol are scalars.\n    the code keeps, roughly, the local error of y(i) below rtol*abs(y(i))+atol . itol=1 : both rtol and atol are vectors.\n    the code keeps the local error of y(i) below rtol(i)*abs(y(i))+atol(i) . Source Code subroutine dop853 ( me , x , y , xend , rtol , atol , iout , idid ) implicit none class ( dop853_class ), intent ( inout ) :: me real ( wp ), intent ( inout ) :: x !! *input:* initial value of independent variable. !! *output:* `x` for which the solution has been computed !! (after successful return `x=xend`). real ( wp ), dimension (:), intent ( inout ) :: y !! *input:* initial values for `y`. [size n] !! *output:* numerical solution at `x`. real ( wp ), intent ( in ) :: xend !! final x-value (xend-x may be positive or negative) real ( wp ), dimension (:), intent ( in ) :: rtol !! relative error tolerance. `rtol` and `atol` !! can be both scalars or else both vectors of length `n`. real ( wp ), dimension (:), intent ( in ) :: atol !! absolute error tolerance. `rtol` and `atol` !! can be both scalars or else both vectors of length `n`. !! `atol` should be strictly positive (possibly very small) integer , intent ( in ) :: iout !! switch for calling the subroutine `solout`: !!  `iout=0`: subroutine is never called !!  `iout=1`: subroutine is called after every successful step !!  `iout=2`: dense output is performed after every successful step !!  `iout=3`: dense output is performed in steps defined by the user !!          (see `xout` above) integer , intent ( out ) :: idid !! reports on successfulness upon return: !!  `idid=1`  computation successful, !!  `idid=2`  comput. successful (interrupted by [[solout]]), !!  `idid=-1` input is not consistent, !!  `idid=-2` larger `nmax` is needed, !!  `idid=-3` step size becomes too small. !!  `idid=-4` problem is probably stiff (interrupted). real ( wp ) :: beta , fac1 , fac2 , h , hmax , safe integer :: i , ieco , iprint , istore , nrdens , nstiff , nmax logical :: arret integer :: itol !! switch for `rtol` and `atol`: !!  `itol=0`: both `rtol` and `atol` are scalars. !!    the code keeps, roughly, the local error of !!    `y(i)` below `rtol*abs(y(i))+atol`. !!  `itol=1`: both `rtol` and `atol` are vectors. !!    the code keeps the local error of `y(i)` below !!    `rtol(i)*abs(y(i))+atol(i)`. iprint = me % iprint arret = . false . !check procedures: if (. not . associated ( me % fcn )) then if ( iprint /= 0 ) & write ( iprint , * ) & 'Error in dop853: procedure FCN is not associated.' idid = - 1 return end if if ( iout /= 0 . and . . not . associated ( me % solout )) then if ( iprint /= 0 ) & write ( iprint , * ) & 'Error in dop853: procedure SOLOUT must be associated if IOUT/=0.' idid = - 1 return end if !scalar or vector tolerances: if ( size ( rtol ) == 1 . and . size ( atol ) == 1 ) then itol = 0 elseif ( size ( rtol ) == me % n . and . size ( atol ) == me % n ) then itol = 1 else if ( iprint /= 0 ) & write ( iprint , * ) & 'Error in dop853: improper dimensions for rtol and/or atol.' idid = - 1 return end if ! setting the parameters me % nfcn = 0 me % nstep = 0 me % naccpt = 0 me % nrejct = 0 nmax = me % nmax nrdens = me % nrdens !number of dense output components ! nstiff parameter for stiffness detection if ( me % nstiff <= 0 ) then nstiff = nmax + 10 !no stiffness check else nstiff = me % nstiff end if if ( nrdens < 0 . or . me % nrdens > me % n ) then if ( iprint /= 0 ) write ( iprint , * ) ' curious input nrdens=' , nrdens arret = . true . else if ( nrdens > 0 . and . iout < 2 . and . iprint /= 0 ) & write ( iprint , * ) ' warning: set iout=2 or iout=3 for dense output ' end if if ( size ( y ) /= me % n ) then if ( iprint /= 0 ) & write ( iprint , * ) ' error: y must have n elements: size(y)= ' , size ( y ) arret = . true . end if safe = me % safe fac1 = me % fac1 fac2 = me % fac2 beta = me % beta if ( me % hmax == 0.0_wp ) then hmax = xend - x else hmax = me % hmax end if h = me % hinitial ! initial step size me % h = h ! when a fail has occured, we return with idid=-1 if ( arret ) then idid = - 1 else ! call to core integrator call me % dp86co ( x , y , xend , hmax , h , rtol , atol , itol , iprint , & iout , idid , nmax , nstiff , safe , beta , fac1 , fac2 , & me % nfcn , me % nstep , me % naccpt , me % nrejct ) me % h = h ! may have been updated end if end subroutine dop853","tags":"","loc":"proc/dop853.html","title":"dop853 – dop853"},{"text":"public subroutine dp86co(me, x, y, xend, hmax, h, rtol, atol, itol, iprint, iout, idid, nmax, nstiff, safe, beta, fac1, fac2, nfcn, nstep, naccpt, nrejct) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(inout) :: me real(kind=wp), intent(inout) :: x real(kind=wp), intent(inout), dimension(:) :: y real(kind=wp), intent(in) :: xend real(kind=wp), intent(inout) :: hmax real(kind=wp), intent(inout) :: h real(kind=wp), intent(in), dimension(:) :: rtol real(kind=wp), intent(in), dimension(:) :: atol integer, intent(in) :: itol integer, intent(in) :: iprint integer, intent(in) :: iout integer, intent(out) :: idid integer, intent(in) :: nmax integer, intent(in) :: nstiff real(kind=wp), intent(in) :: safe real(kind=wp), intent(in) :: beta real(kind=wp), intent(in) :: fac1 real(kind=wp), intent(in) :: fac2 integer, intent(inout) :: nfcn integer, intent(inout) :: nstep integer, intent(inout) :: naccpt integer, intent(inout) :: nrejct Description Core integrator for dop853 .\n  parameters same as in dop853 with workspace added. Variables Type Visibility Attributes Name Initial real(kind=wp), public, dimension(me%n) :: y1 real(kind=wp), public, dimension(me%n) :: k1 real(kind=wp), public, dimension(me%n) :: k2 real(kind=wp), public, dimension(me%n) :: k3 real(kind=wp), public, dimension(me%n) :: k4 real(kind=wp), public, dimension(me%n) :: k5 real(kind=wp), public, dimension(me%n) :: k6 real(kind=wp), public, dimension(me%n) :: k7 real(kind=wp), public, dimension(me%n) :: k8 real(kind=wp), public, dimension(me%n) :: k9 real(kind=wp), public, dimension(me%n) :: k10 real(kind=wp), public :: atoli real(kind=wp), public :: bspl real(kind=wp), public :: deno real(kind=wp), public :: err real(kind=wp), public :: err2 real(kind=wp), public :: erri real(kind=wp), public :: expo1 real(kind=wp), public :: fac real(kind=wp), public :: fac11 real(kind=wp), public :: facc1 real(kind=wp), public :: facc2 real(kind=wp), public :: facold real(kind=wp), public :: hlamb real(kind=wp), public :: hnew real(kind=wp), public :: posneg real(kind=wp), public :: rtoli real(kind=wp), public :: sk real(kind=wp), public :: stden real(kind=wp), public :: stnum real(kind=wp), public :: xout real(kind=wp), public :: xph real(kind=wp), public :: ydiff integer, public :: i integer, public :: iasti integer, public :: iord integer, public :: irtrn integer, public :: j integer, public :: nonsti integer, public :: nrd logical, public :: reject logical, public :: last logical, public :: event logical, public :: abort Source Code subroutine dp86co ( me , x , y , xend , hmax , h , rtol , atol , itol , iprint , & iout , idid , nmax , nstiff , safe , & beta , fac1 , fac2 , & nfcn , nstep , naccpt , nrejct ) implicit none class ( dop853_class ), intent ( inout ) :: me real ( wp ), intent ( inout ) :: x real ( wp ), dimension (:), intent ( inout ) :: y real ( wp ), intent ( in ) :: xend real ( wp ), intent ( inout ) :: hmax real ( wp ), intent ( inout ) :: h real ( wp ), dimension (:), intent ( in ) :: rtol real ( wp ), dimension (:), intent ( in ) :: atol integer , intent ( in ) :: itol integer , intent ( in ) :: iprint integer , intent ( in ) :: iout integer , intent ( out ) :: idid integer , intent ( in ) :: nmax integer , intent ( in ) :: nstiff real ( wp ), intent ( in ) :: safe real ( wp ), intent ( in ) :: beta real ( wp ), intent ( in ) :: fac1 real ( wp ), intent ( in ) :: fac2 integer , intent ( inout ) :: nfcn integer , intent ( inout ) :: nstep integer , intent ( inout ) :: naccpt integer , intent ( inout ) :: nrejct real ( wp ), dimension ( me % n ) :: y1 , k1 , k2 , k3 , k4 , k5 , k6 , k7 , k8 , k9 , k10 real ( wp ) :: atoli , bspl , deno , err , err2 , erri , expo1 , fac , fac11 ,& facc1 , facc2 , facold , hlamb , hnew , posneg , rtoli ,& sk , stden , stnum , xout , xph , ydiff integer :: i , iasti , iord , irtrn , j , nonsti , nrd logical :: reject , last , event , abort ! initialisations nrd = me % nrdens facold = 1.0e-4_wp expo1 = 1.0_wp / 8.0_wp - beta * 0.2_wp facc1 = 1.0_wp / fac1 facc2 = 1.0_wp / fac2 posneg = sign ( 1.0_wp , xend - x ) ! initial preparations atoli = atol ( 1 ) rtoli = rtol ( 1 ) last = . false . hlamb = 0.0_wp iasti = 0 call me % fcn ( x , y , k1 ) hmax = abs ( hmax ) iord = 8 if ( h == 0.0_wp ) then h = me % hinit ( x , y , posneg , k1 , iord , hmax , atol , rtol , itol ) end if nfcn = nfcn + 2 reject = . false . me % xold = x if ( iout /= 0 ) then irtrn = 1 me % hout = 1.0_wp call me % solout ( naccpt + 1 , me % xold , x , y , irtrn , xout ) abort = ( irtrn < 0 ) else abort = . false . end if if (. not . abort ) then do ! basic integration step if ( nstep > nmax ) then if ( iprint /= 0 ) & write ( iprint , '(A,E18.4)' ) ' exit of dop853 at x=' , x if ( iprint /= 0 ) & write ( iprint , * ) ' more than nmax =' , nmax , 'steps are needed' idid = - 2 return elseif ( 0.1_wp * abs ( h ) <= abs ( x ) * uround ) then if ( iprint /= 0 ) & write ( iprint , '(A,E18.4)' ) ' exit of dop853 at x=' , x if ( iprint /= 0 ) & write ( iprint , * ) ' step size too small, h=' , h idid = - 3 return else if ( ( x + 1.01_wp * h - xend ) * posneg > 0.0_wp ) then h = xend - x last = . true . end if nstep = nstep + 1 ! the twelve stages if ( irtrn >= 2 ) call me % fcn ( x , y , k1 ) y1 = y + h * a21 * k1 call me % fcn ( x + c2 * h , y1 , k2 ) y1 = y + h * ( a31 * k1 + a32 * k2 ) call me % fcn ( x + c3 * h , y1 , k3 ) y1 = y + h * ( a41 * k1 + a43 * k3 ) call me % fcn ( x + c4 * h , y1 , k4 ) y1 = y + h * ( a51 * k1 + a53 * k3 + a54 * k4 ) call me % fcn ( x + c5 * h , y1 , k5 ) y1 = y + h * ( a61 * k1 + a64 * k4 + a65 * k5 ) call me % fcn ( x + c6 * h , y1 , k6 ) y1 = y + h * ( a71 * k1 + a74 * k4 + a75 * k5 + a76 * k6 ) call me % fcn ( x + c7 * h , y1 , k7 ) y1 = y + h * ( a81 * k1 + a84 * k4 + a85 * k5 + a86 * k6 + a87 * k7 ) call me % fcn ( x + c8 * h , y1 , k8 ) y1 = y + h * ( a91 * k1 + a94 * k4 + a95 * k5 + a96 * k6 + a97 * k7 + a98 * k8 ) call me % fcn ( x + c9 * h , y1 , k9 ) y1 = y + h * ( a101 * k1 + a104 * k4 + a105 * k5 + a106 * k6 + a107 * k7 + & a108 * k8 + a109 * k9 ) call me % fcn ( x + c10 * h , y1 , k10 ) y1 = y + h * ( a111 * k1 + a114 * k4 + a115 * k5 + a116 * k6 + a117 * k7 + & a118 * k8 + a119 * k9 + a1110 * k10 ) call me % fcn ( x + c11 * h , y1 , k2 ) xph = x + h y1 = y + h * ( a121 * k1 + a124 * k4 + a125 * k5 + a126 * k6 + a127 * k7 + & a128 * k8 + a129 * k9 + a1210 * k10 + a1211 * k2 ) call me % fcn ( xph , y1 , k3 ) nfcn = nfcn + 11 k4 = b1 * k1 + b6 * k6 + b7 * k7 + b8 * k8 + b9 * k9 + b10 * k10 + b11 * k2 + b12 * k3 k5 = y + h * k4 ! error estimation err = 0.0_wp err2 = 0.0_wp if ( itol == 0 ) then do i = 1 , me % n sk = atoli + rtoli * max ( abs ( y ( i )), abs ( k5 ( i ))) erri = k4 ( i ) - bhh1 * k1 ( i ) - bhh2 * k9 ( i ) - bhh3 * k3 ( i ) err2 = err2 + ( erri / sk ) ** 2 erri = er1 * k1 ( i ) + er6 * k6 ( i ) + er7 * k7 ( i ) + er8 * k8 ( i ) & + er9 * k9 ( i ) + er10 * k10 ( i ) + er11 * k2 ( i ) & + er12 * k3 ( i ) err = err + ( erri / sk ) ** 2 end do else do i = 1 , me % n sk = atol ( i ) + rtol ( i ) * max ( abs ( y ( i )), abs ( k5 ( i ))) erri = k4 ( i ) - bhh1 * k1 ( i ) - bhh2 * k9 ( i ) - bhh3 * k3 ( i ) err2 = err2 + ( erri / sk ) ** 2 erri = er1 * k1 ( i ) + er6 * k6 ( i ) + er7 * k7 ( i ) + er8 * k8 ( i ) & + er9 * k9 ( i ) + er10 * k10 ( i ) + er11 * k2 ( i ) & + er12 * k3 ( i ) err = err + ( erri / sk ) ** 2 end do end if deno = err + 0.01_wp * err2 if ( deno <= 0.0_wp ) deno = 1.0_wp err = abs ( h ) * err * sqrt ( 1.0_wp / ( me % n * deno )) ! computation of hnew fac11 = err ** expo1 ! lund-stabilization fac = fac11 / facold ** beta ! we require  fac1 <= hnew/h <= fac2 fac = max ( facc2 , min ( facc1 , fac / safe )) hnew = h / fac if ( err <= 1.0_wp ) then ! step is accepted facold = max ( err , 1.0e-4_wp ) naccpt = naccpt + 1 call me % fcn ( xph , k5 , k4 ) nfcn = nfcn + 1 ! stiffness detection if ( mod ( naccpt , nstiff ) == 0 . or . iasti > 0 ) then stnum = 0.0_wp stden = 0.0_wp do i = 1 , me % n stnum = stnum + ( k4 ( i ) - k3 ( i )) ** 2 stden = stden + ( k5 ( i ) - y1 ( i )) ** 2 end do if ( stden > 0.0_wp ) hlamb = abs ( h ) * sqrt ( stnum / stden ) if ( hlamb > 6.1_wp ) then nonsti = 0 iasti = iasti + 1 if ( iasti == 15 ) then if ( iprint /= 0 ) & write ( iprint , * ) & ' the problem seems to become stiff at x = ' , x if ( iprint == 0 ) then idid = - 4 ! fail exit return end if end if else nonsti = nonsti + 1 if ( nonsti == 6 ) iasti = 0 end if end if ! final preparation for dense output event = ( iout == 3 ) . and . ( xout <= xph ) if ( iout == 2 . or . event ) then ! save the first function evaluations do j = 1 , nrd i = me % icomp ( j ) me % cont ( j ) = y ( i ) ydiff = k5 ( i ) - y ( i ) me % cont ( j + nrd ) = ydiff bspl = h * k1 ( i ) - ydiff me % cont ( j + nrd * 2 ) = bspl me % cont ( j + nrd * 3 ) = ydiff - h * k4 ( i ) - bspl me % cont ( j + nrd * 4 ) = d41 * k1 ( i ) + d46 * k6 ( i ) + d47 * k7 ( i ) + & d48 * k8 ( i ) + d49 * k9 ( i ) + d410 * k10 ( i ) + & d411 * k2 ( i ) + d412 * k3 ( i ) me % cont ( j + nrd * 5 ) = d51 * k1 ( i ) + d56 * k6 ( i ) + d57 * k7 ( i ) + & d58 * k8 ( i ) + d59 * k9 ( i ) + d510 * k10 ( i ) + & d511 * k2 ( i ) + d512 * k3 ( i ) me % cont ( j + nrd * 6 ) = d61 * k1 ( i ) + d66 * k6 ( i ) + d67 * k7 ( i ) + & d68 * k8 ( i ) + d69 * k9 ( i ) + d610 * k10 ( i ) + & d611 * k2 ( i ) + d612 * k3 ( i ) me % cont ( j + nrd * 7 ) = d71 * k1 ( i ) + d76 * k6 ( i ) + d77 * k7 ( i ) + & d78 * k8 ( i ) + d79 * k9 ( i ) + d710 * k10 ( i ) + & d711 * k2 ( i ) + d712 * k3 ( i ) end do ! the next three function evaluations y1 = y + h * ( a141 * k1 + a147 * k7 + a148 * k8 + a149 * k9 + & a1410 * k10 + a1411 * k2 + a1412 * k3 + a1413 * k4 ) call me % fcn ( x + c14 * h , y1 , k10 ) y1 = y + h * ( a151 * k1 + a156 * k6 + a157 * k7 + a158 * k8 + & a1511 * k2 + a1512 * k3 + a1513 * k4 + a1514 * k10 ) call me % fcn ( x + c15 * h , y1 , k2 ) y1 = y + h * ( a161 * k1 + a166 * k6 + a167 * k7 + a168 * k8 + a169 * k9 + & a1613 * k4 + a1614 * k10 + a1615 * k2 ) call me % fcn ( x + c16 * h , y1 , k3 ) nfcn = nfcn + 3 ! final preparation do j = 1 , nrd i = me % icomp ( j ) me % cont ( j + nrd * 4 ) = h * ( me % cont ( j + nrd * 4 ) + d413 * k4 ( i ) + & d414 * k10 ( i ) + d415 * k2 ( i ) + d416 * k3 ( i )) me % cont ( j + nrd * 5 ) = h * ( me % cont ( j + nrd * 5 ) + d513 * k4 ( i ) + & d514 * k10 ( i ) + d515 * k2 ( i ) + d516 * k3 ( i )) me % cont ( j + nrd * 6 ) = h * ( me % cont ( j + nrd * 6 ) + d613 * k4 ( i ) + & d614 * k10 ( i ) + d615 * k2 ( i ) + d616 * k3 ( i )) me % cont ( j + nrd * 7 ) = h * ( me % cont ( j + nrd * 7 ) + d713 * k4 ( i ) + & d714 * k10 ( i ) + d715 * k2 ( i ) + d716 * k3 ( i )) end do me % hout = h end if k1 = k4 y = k5 me % xold = x x = xph if ( iout == 1 . or . iout == 2 . or . event ) then call me % solout ( naccpt + 1 , me % xold , x , y , irtrn , xout ) if ( irtrn < 0 ) exit !abort end if ! normal exit if ( last ) then h = hnew idid = 1 return end if if ( abs ( hnew ) > hmax ) hnew = posneg * hmax if ( reject ) hnew = posneg * min ( abs ( hnew ), abs ( h )) reject = . false . else ! step is rejected hnew = h / min ( facc1 , fac11 / safe ) reject = . true . if ( naccpt >= 1 ) nrejct = nrejct + 1 last = . false . end if h = hnew end if end do end if if ( iprint /= 0 ) write ( iprint , '(A,E18.4)' ) ' exit of dop853 at x=' , x idid = 2 end subroutine dp86co","tags":"","loc":"proc/dp86co.html","title":"dp86co – dop853"},{"text":"subroutine solout(me, nr, xold, x, y, irtrn, xout) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(inout) :: me integer, intent(in) :: nr real(kind=wp), intent(in) :: xold real(kind=wp), intent(in) :: x real(kind=wp), intent(in), dimension(:) :: y integer, intent(inout) :: irtrn real(kind=wp), intent(out) :: xout the point where we want the next output reported Description Prints solution at equidistant output-points\n  by using contd8 , the continuous collocation solution.\n  This is for an iout=3 case. Note This routine uses Fortran 2008 LHS automatic allocations. Source Code subroutine solout ( me , nr , xold , x , y , irtrn , xout ) implicit none class ( dop853_class ), intent ( inout ) :: me integer , intent ( in ) :: nr real ( wp ), intent ( in ) :: xold real ( wp ), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y integer , intent ( inout ) :: irtrn real ( wp ), intent ( out ) :: xout !! the point where we want the next output reported if ( nr == 1 ) then write ( output_unit , '(1X,A,F6.2,A,2E18.10,A,I4)' ) & 'x =' , x ,& '    y =' , y ( 1 ), y ( 2 ),& '    nstep =' , nr - 1 xout = dx else do if ( x < xout ) exit write ( output_unit , '(1X,A,F6.2,A,2E18.10,A,I4)' ) & 'x =' , xout ,& '    y =' ,& prop % contd8 ( 1 , xout ),& prop % contd8 ( 2 , xout ),& '    nstep =' , nr - 1 xout = xout + dx end do end if if ( make_plots ) then if ( allocated ( t_vec )) then !fortran 2008 lhs allocations t_vec = [ t_vec , x ] y_vec = [ y_vec , y ( 1 )] yp_vec = [ yp_vec , y ( 2 )] else t_vec = [ x ] y_vec = [ y ( 1 )] yp_vec = [ y ( 2 )] end if end if end subroutine solout","tags":"","loc":"proc/solout.html","title":"solout – dop853"},{"text":"subroutine solout2(me, nr, xold, x, y, irtrn, xout) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(inout) :: me integer, intent(in) :: nr real(kind=wp), intent(in) :: xold real(kind=wp), intent(in) :: x real(kind=wp), intent(in), dimension(:) :: y integer, intent(inout) :: irtrn real(kind=wp), intent(out) :: xout not used for iout=1 . Description Prints a normal step from dop853 (for iout=1 ). Note This routine uses Fortran 2008 LHS automatic allocations. Source Code subroutine solout2 ( me , nr , xold , x , y , irtrn , xout ) implicit none class ( dop853_class ), intent ( inout ) :: me integer , intent ( in ) :: nr real ( wp ), intent ( in ) :: xold real ( wp ), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y integer , intent ( inout ) :: irtrn real ( wp ), intent ( out ) :: xout !! not used for `iout=1`. write ( output_unit , '(1X,A,F6.2,A,2E18.10,A,I4)' ) & 'x =' , x ,& '    y =' , y ( 1 ), y ( 2 ),& '    nstep =' , nr - 1 if ( make_plots ) then if ( allocated ( t_vec )) then t_vec = [ t_vec , x ] y_vec = [ y_vec , y ( 1 )] yp_vec = [ yp_vec , y ( 2 )] else t_vec = [ x ] y_vec = [ y ( 1 )] yp_vec = [ y ( 2 )] end if end if end subroutine solout2","tags":"","loc":"proc/solout2.html","title":"solout2 – dop853"},{"text":"subroutine fvpol(me, x, y, f) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in), dimension(:) :: y  [y, y' ]  real(kind=wp), intent(out), dimension(:) :: f  [y', y'' ]  Description Right-hand side of van der Pol's equation:\n  y'' = \\mu(1-y&#94;2)y' - y . Reference Weisstein, Eric W. \" van der Pol Equation .\"\n   From MathWorld--A Wolfram Web Resource. Note The original code had a slightly different equation. Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: mu = 0.2_wp  \\mu  in van der Pol's equation. Source Code subroutine fvpol ( me , x , y , f ) implicit none class ( dop853_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y !!  [y, y' ]  real ( wp ), dimension (:), intent ( out ) :: f !!  [y', y'' ]  real ( wp ), parameter :: mu = 0.2_wp !!  \\mu  in van der Pol's equation. f ( 1 ) = y ( 2 ) f ( 2 ) = mu * ( 1.0_wp - y ( 1 ) ** 2 ) * y ( 2 ) - y ( 1 ) end subroutine fvpol","tags":"","loc":"proc/fvpol.html","title":"fvpol – dop853"},{"text":"Uses: dop853_constants iso_fortran_env module~~dop853_module~~UsesGraph module~dop853_module dop853_module module~dop853_constants dop853_constants module~dop853_constants->module~dop853_module iso_fortran_env iso_fortran_env iso_fortran_env->module~dop853_module iso_fortran_env->module~dop853_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Modern Fortran Edition of the DOP853 ODE Solver. See also DOP853.f History Jacob Williams : December 2015 : Created module from the DOP853 Fortran 77 code. Development continues at GitHub . License Original DOP853 license: Copyright (c) 2004, Ernst Hairer\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions are\n    met:\n\n    - Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer.\n\n    - Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the\n    documentation and/or other materials provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n    IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n    TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n    PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. License for updated version: Modern Fortran Edition of the DOP853 ODE Solver\n    https://github.com/jacobwilliams/dop853\n\n    Copyright (c) 2015, Jacob Williams\n    All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without modification,\n    are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice, this\n      list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above copyright notice, this\n      list of conditions and the following disclaimer in the documentation and/or\n      other materials provided with the distribution.\n\n    * The names of its contributors may not be used to endorse or promote products\n      derived from this software without specific prior written permission.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n    ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n    ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Used By module~~dop853_module~~UsedByGraph module~dop853_module dop853_module program~dop853_test dop853_test module~dop853_module->program~dop853_test Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface public subroutine deriv_func (me, x, y, f) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(inout) :: me real(kind=wp), intent(in) :: x independent variable x real(kind=wp), intent(in), dimension(:) :: y state vector  y(x)  [size n] real(kind=wp), intent(out), dimension(:) :: f derivative vector  f(x,y) = dy/dx  [size n] Description subroutine computing the value of  dy/dx = f(x,y)  abstract interface public subroutine solout_func (me, nr, xold, x, y, irtrn, xout) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(inout) :: me integer, intent(in) :: nr grid point (0,1,...) real(kind=wp), intent(in) :: xold the preceeding grid point real(kind=wp), intent(in) :: x current grid point real(kind=wp), intent(in), dimension(:) :: y state vector  y(x)  [size n] integer, intent(inout) :: irtrn serves to interrupt the integration. if irtrn is set <0 , dop853 will return to\n the calling program. if the numerical solution\n is altered in solout , set irtrn = 2 . real(kind=wp), intent(out) :: xout xout can be used for efficient intermediate output\n if one puts iout=3 . when nr=1 define the first\n output point xout in solout . the subroutine solout will be called only when xout is in the\n interval [xold,x] ; during this call\n a new value for xout can be defined, etc. Description solout furnishes the solution y at the nr -th\n grid-point x (thereby the initial value is\n the first grid-point). Derived Types type, public :: dop853_class Components Type Visibility Attributes Name Initial integer, private :: n = 0 the dimension of the system integer, private :: nfcn = 0 number of function evaluations integer, private :: nstep = 0 number of computed steps integer, private :: naccpt = 0 number of accepted steps integer, private :: nrejct = 0 number of rejected steps (due to error test),\n (step rejections in the first step are not counted) integer, private :: nrdens = 0 number of components, for which dense output\n is required. for 0 < nrdens < n the components\n (for which dense output is required) have to be\n specified in icomp(1),...,icomp(nrdens) . real(kind=wp), private :: h = 0.0_wp predicted step size of the last accepted step integer, private :: iprint = output_unit switch for printing error messages\n if iprint==0 no messages are being printed\n if iprint/=0 messages are printed with write (iprint,*) ... integer, private :: nmax = 100000 the maximal number of allowed steps. integer, private :: nstiff = 1000 test for stiffness is activated after step number j*nstiff ( j integer), provided nstiff>0 .\n for negative nstiff the stiffness test is\n never activated. real(kind=wp), private :: hinitial = 0.0_wp initial step size, for hinitial=0 an initial guess\n is computed with help of the function hinit . real(kind=wp), private :: hmax = 0.0_wp maximal step size, defaults to xend-x if hmax=0 . real(kind=wp), private :: safe = 0.9_wp safety factor in step size prediction real(kind=wp), private :: fac1 = 0.333_wp parameter for step size selection.\n the new step size is chosen subject to the restriction fac1 <= hnew/hold <= fac2 real(kind=wp), private :: fac2 = 6.0_wp parameter for step size selection.\n the new step size is chosen subject to the restriction fac1 <= hnew/hold <= fac2 real(kind=wp), private :: beta = 0.0_wp is the beta for stabilized step size control\n (see section iv.2). positive values of beta ( <= 0.04 )\n make the step size control more stable. integer, private, dimension(:), allocatable :: icomp dimension(nrdens) the components for which dense output is required real(kind=wp), private, dimension(:), allocatable :: cont dimension(8*nrdens) real(kind=wp), private :: xold = 0.0_wp real(kind=wp), private :: hout = 0.0_wp procedure( deriv_func ), private, pointer :: fcn => null() subroutine computing the value of f(x,y) procedure( solout_func ), private, pointer :: solout => null() subroutine providing the\n numerical solution during integration.\n if iout>=1 , it is called during integration. Type-Bound Procedures procedure, public :: initialize => set_parameters initialization routine. procedure, public :: integrate => dop853 main integration routine. procedure, public :: destroy => destroy_dop853 destructor. procedure, public :: info => get_dop853_info to get info after a run. procedure, private :: dp86co procedure, private :: hinit procedure, public :: contd8 can be called in user's solout_func for dense output. Functions public function hinit (me, x, y, posneg, f0, iord, hmax, atol, rtol, itol) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in), dimension(:) :: y dimension(n) real(kind=wp), intent(in) :: posneg real(kind=wp), intent(in), dimension(:) :: f0 dimension(n) integer, intent(in) :: iord real(kind=wp), intent(in) :: hmax real(kind=wp), intent(in), dimension(:) :: atol real(kind=wp), intent(in), dimension(:) :: rtol integer, intent(in) :: itol Return Value real(kind=wp) Description computation of an initial step size guess public function contd8 (me, ii, x) result(y) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(in) :: me integer, intent(in) :: ii real(kind=wp), intent(in) :: x Return Value real(kind=wp) Description this function can be used for continuous output in connection\n  with the output-subroutine for dop853 . it provides an\n  approximation to the ii -th component of the solution at x . Subroutines public subroutine get_dop853_info (me, n, nfcn, nstep, naccpt, nrejct, h) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(in) :: me integer, intent(out), optional :: n dimension of the system integer, intent(out), optional :: nfcn number of function evaluations integer, intent(out), optional :: nstep number of computed steps integer, intent(out), optional :: naccpt number of accepted steps integer, intent(out), optional :: nrejct number of rejected steps (due to error test),\n (step rejections in the first step are not counted) real(kind=wp), intent(out), optional :: h predicted step size of the last accepted step Description Get info from a dop853_class . public subroutine destroy_dop853 (me) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(out) :: me Description Destructor for dop853_class . public subroutine set_parameters (me, n, fcn, solout, iprint, nstiff, nmax, hinitial, hmax, safe, fac1, fac2, beta, icomp, status_ok) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(inout) :: me integer, intent(in) :: n the dimension of the system (size of y and y' vectors) procedure( deriv_func ) :: fcn subroutine computing the value of  y' = f(x,y)  procedure( solout_func ) , optional :: solout subroutine providing the\n numerical solution during integration.\n if iout>=1 , it is called during integration.\n supply a dummy subroutine if iout=0 . integer, intent(in), optional :: iprint switch for printing error messages\n if iprint==0 no messages are being printed\n if iprint/=0 messages are printed with write (iprint,*) ... integer, intent(in), optional :: nstiff test for stiffness is activated after step number j*nstiff ( j integer), provided nstiff>0 .\n for negative nstiff the stiffness test is\n never activated. integer, intent(in), optional :: nmax the maximal number of allowed steps. real(kind=wp), intent(in), optional :: hinitial initial step size, for hinitial=0 an initial guess\n is computed with help of the function hinit . real(kind=wp), intent(in), optional :: hmax maximal step size, defaults to xend-x if hmax=0 . real(kind=wp), intent(in), optional :: safe safety factor in step size prediction real(kind=wp), intent(in), optional :: fac1 parameter for step size selection.\n the new step size is chosen subject to the restriction fac1 <= hnew/hold <= fac2 real(kind=wp), intent(in), optional :: fac2 parameter for step size selection.\n the new step size is chosen subject to the restriction fac1 <= hnew/hold <= fac2 real(kind=wp), intent(in), optional :: beta is the beta for stabilized step size control\n (see section iv.2). positive values of beta ( <= 0.04 )\n make the step size control more stable. integer, intent(in), optional dimension(:) :: icomp the components for which dense output is required (size from 0 to n ). logical, intent(out) :: status_ok will be false for invalid inputs. Description Set the optional inputs for dop853 . public subroutine dop853 (me, x, y, xend, rtol, atol, iout, idid) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(inout) :: me real(kind=wp), intent(inout) :: x input: initial value of independent variable. output: x for which the solution has been computed\n (after successful return x=xend ). real(kind=wp), intent(inout), dimension(:) :: y input: initial values for y . [size n] output: numerical solution at x . real(kind=wp), intent(in) :: xend final x-value (xend-x may be positive or negative) real(kind=wp), intent(in), dimension(:) :: rtol relative error tolerance. rtol and atol can be both scalars or else both vectors of length n . real(kind=wp), intent(in), dimension(:) :: atol absolute error tolerance. rtol and atol can be both scalars or else both vectors of length n . atol should be strictly positive (possibly very small) integer, intent(in) :: iout switch for calling the subroutine solout : iout=0 : subroutine is never called iout=1 : subroutine is called after every successful step iout=2 : dense output is performed after every successful step iout=3 : dense output is performed in steps defined by the user\n          (see xout above) integer, intent(out) :: idid reports on successfulness upon return: idid=1 computation successful, idid=2 comput. successful (interrupted by solout ), idid=-1 input is not consistent, idid=-2 larger nmax is needed, idid=-3 step size becomes too small. idid=-4 problem is probably stiff (interrupted). Description Numerical solution of a system of first order\n  ordinary differential equations  y'=f(x,y) .\n  This is an explicit Runge-Kutta method of order 8(5,3)\n  due to Dormand & Prince (with stepsize control and\n  dense output). public subroutine dp86co (me, x, y, xend, hmax, h, rtol, atol, itol, iprint, iout, idid, nmax, nstiff, safe, beta, fac1, fac2, nfcn, nstep, naccpt, nrejct) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(inout) :: me real(kind=wp), intent(inout) :: x real(kind=wp), intent(inout), dimension(:) :: y real(kind=wp), intent(in) :: xend real(kind=wp), intent(inout) :: hmax real(kind=wp), intent(inout) :: h real(kind=wp), intent(in), dimension(:) :: rtol real(kind=wp), intent(in), dimension(:) :: atol integer, intent(in) :: itol integer, intent(in) :: iprint integer, intent(in) :: iout integer, intent(out) :: idid integer, intent(in) :: nmax integer, intent(in) :: nstiff real(kind=wp), intent(in) :: safe real(kind=wp), intent(in) :: beta real(kind=wp), intent(in) :: fac1 real(kind=wp), intent(in) :: fac2 integer, intent(inout) :: nfcn integer, intent(inout) :: nstep integer, intent(inout) :: naccpt integer, intent(inout) :: nrejct Description Core integrator for dop853 .\n  parameters same as in dop853 with workspace added.","tags":"","loc":"module/dop853_module.html","title":"dop853_module – dop853"},{"text":"Uses: iso_fortran_env module~~dop853_constants~~UsesGraph module~dop853_constants dop853_constants iso_fortran_env iso_fortran_env iso_fortran_env->module~dop853_constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Constants used by dop853_module . Used By module~~dop853_constants~~UsedByGraph module~dop853_constants dop853_constants program~dop853_test dop853_test module~dop853_constants->program~dop853_test module~dop853_module dop853_module module~dop853_constants->module~dop853_module module~dop853_module->program~dop853_test Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: uround = epsilon(1.0_wp) machine  \\epsilon  real(kind=wp), public, parameter :: c2 = 0.526001519587677318785587544488e-01_wp real(kind=wp), public, parameter :: c3 = 0.789002279381515978178381316732e-01_wp real(kind=wp), public, parameter :: c4 = 0.118350341907227396726757197510_wp real(kind=wp), public, parameter :: c5 = 0.281649658092772603273242802490_wp real(kind=wp), public, parameter :: c6 = 0.333333333333333333333333333333_wp real(kind=wp), public, parameter :: c7 = 0.25_wp real(kind=wp), public, parameter :: c8 = 0.307692307692307692307692307692_wp real(kind=wp), public, parameter :: c9 = 0.651282051282051282051282051282_wp real(kind=wp), public, parameter :: c10 = 0.6_wp real(kind=wp), public, parameter :: c11 = 0.857142857142857142857142857142_wp real(kind=wp), public, parameter :: c14 = 0.1_wp real(kind=wp), public, parameter :: c15 = 0.2_wp real(kind=wp), public, parameter :: c16 = 0.777777777777777777777777777778_wp real(kind=wp), public, parameter :: b1 = 5.42937341165687622380535766363e-2_wp real(kind=wp), public, parameter :: b6 = 4.45031289275240888144113950566_wp real(kind=wp), public, parameter :: b7 = 1.89151789931450038304281599044_wp real(kind=wp), public, parameter :: b8 = -5.8012039600105847814672114227_wp real(kind=wp), public, parameter :: b9 = 3.1116436695781989440891606237e-1_wp real(kind=wp), public, parameter :: b10 = -1.52160949662516078556178806805e-1_wp real(kind=wp), public, parameter :: b11 = 2.01365400804030348374776537501e-1_wp real(kind=wp), public, parameter :: b12 = 4.47106157277725905176885569043e-2_wp real(kind=wp), public, parameter :: bhh1 = 0.244094488188976377952755905512_wp real(kind=wp), public, parameter :: bhh2 = 0.733846688281611857341361741547_wp real(kind=wp), public, parameter :: bhh3 = 0.220588235294117647058823529412e-1_wp real(kind=wp), public, parameter :: er1 = 0.1312004499419488073250102996e-01_wp real(kind=wp), public, parameter :: er6 = -0.1225156446376204440720569753e+01_wp real(kind=wp), public, parameter :: er7 = -0.4957589496572501915214079952_wp real(kind=wp), public, parameter :: er8 = 0.1664377182454986536961530415e+01_wp real(kind=wp), public, parameter :: er9 = -0.3503288487499736816886487290_wp real(kind=wp), public, parameter :: er10 = 0.3341791187130174790297318841_wp real(kind=wp), public, parameter :: er11 = 0.8192320648511571246570742613e-01_wp real(kind=wp), public, parameter :: er12 = -0.2235530786388629525884427845e-01_wp real(kind=wp), public, parameter :: a21 = 5.26001519587677318785587544488e-2_wp real(kind=wp), public, parameter :: a31 = 1.97250569845378994544595329183e-2_wp real(kind=wp), public, parameter :: a32 = 5.91751709536136983633785987549e-2_wp real(kind=wp), public, parameter :: a41 = 2.95875854768068491816892993775e-2_wp real(kind=wp), public, parameter :: a43 = 8.87627564304205475450678981324e-2_wp real(kind=wp), public, parameter :: a51 = 2.41365134159266685502369798665e-1_wp real(kind=wp), public, parameter :: a53 = -8.84549479328286085344864962717e-1_wp real(kind=wp), public, parameter :: a54 = 9.24834003261792003115737966543e-1_wp real(kind=wp), public, parameter :: a61 = 3.7037037037037037037037037037e-2_wp real(kind=wp), public, parameter :: a64 = 1.70828608729473871279604482173e-1_wp real(kind=wp), public, parameter :: a65 = 1.25467687566822425016691814123e-1_wp real(kind=wp), public, parameter :: a71 = 3.7109375e-2_wp real(kind=wp), public, parameter :: a74 = 1.70252211019544039314978060272e-1_wp real(kind=wp), public, parameter :: a75 = 6.02165389804559606850219397283e-2_wp real(kind=wp), public, parameter :: a76 = -1.7578125e-2_wp real(kind=wp), public, parameter :: a81 = 3.70920001185047927108779319836e-2_wp real(kind=wp), public, parameter :: a84 = 1.70383925712239993810214054705e-1_wp real(kind=wp), public, parameter :: a85 = 1.07262030446373284651809199168e-1_wp real(kind=wp), public, parameter :: a86 = -1.53194377486244017527936158236e-2_wp real(kind=wp), public, parameter :: a87 = 8.27378916381402288758473766002e-3_wp real(kind=wp), public, parameter :: a91 = 6.24110958716075717114429577812e-1_wp real(kind=wp), public, parameter :: a94 = -3.36089262944694129406857109825_wp real(kind=wp), public, parameter :: a95 = -8.68219346841726006818189891453e-1_wp real(kind=wp), public, parameter :: a96 = 2.75920996994467083049415600797e+1_wp real(kind=wp), public, parameter :: a97 = 2.01540675504778934086186788979e+1_wp real(kind=wp), public, parameter :: a98 = -4.34898841810699588477366255144e+1_wp real(kind=wp), public, parameter :: a101 = 4.77662536438264365890433908527e-1_wp real(kind=wp), public, parameter :: a104 = -2.48811461997166764192642586468_wp real(kind=wp), public, parameter :: a105 = -5.90290826836842996371446475743e-1_wp real(kind=wp), public, parameter :: a106 = 2.12300514481811942347288949897e+1_wp real(kind=wp), public, parameter :: a107 = 1.52792336328824235832596922938e+1_wp real(kind=wp), public, parameter :: a108 = -3.32882109689848629194453265587e+1_wp real(kind=wp), public, parameter :: a109 = -2.03312017085086261358222928593e-2_wp real(kind=wp), public, parameter :: a111 = -9.3714243008598732571704021658e-1_wp real(kind=wp), public, parameter :: a114 = 5.18637242884406370830023853209_wp real(kind=wp), public, parameter :: a115 = 1.09143734899672957818500254654_wp real(kind=wp), public, parameter :: a116 = -8.14978701074692612513997267357_wp real(kind=wp), public, parameter :: a117 = -1.85200656599969598641566180701e+1_wp real(kind=wp), public, parameter :: a118 = 2.27394870993505042818970056734e+1_wp real(kind=wp), public, parameter :: a119 = 2.49360555267965238987089396762_wp real(kind=wp), public, parameter :: a1110 = -3.0467644718982195003823669022_wp real(kind=wp), public, parameter :: a121 = 2.27331014751653820792359768449_wp real(kind=wp), public, parameter :: a124 = -1.05344954667372501984066689879e+1_wp real(kind=wp), public, parameter :: a125 = -2.00087205822486249909675718444_wp real(kind=wp), public, parameter :: a126 = -1.79589318631187989172765950534e+1_wp real(kind=wp), public, parameter :: a127 = 2.79488845294199600508499808837e+1_wp real(kind=wp), public, parameter :: a128 = -2.85899827713502369474065508674_wp real(kind=wp), public, parameter :: a129 = -8.87285693353062954433549289258_wp real(kind=wp), public, parameter :: a1210 = 1.23605671757943030647266201528e+1_wp real(kind=wp), public, parameter :: a1211 = 6.43392746015763530355970484046e-1_wp real(kind=wp), public, parameter :: a141 = 5.61675022830479523392909219681e-2_wp real(kind=wp), public, parameter :: a147 = 2.53500210216624811088794765333e-1_wp real(kind=wp), public, parameter :: a148 = -2.46239037470802489917441475441e-1_wp real(kind=wp), public, parameter :: a149 = -1.24191423263816360469010140626e-1_wp real(kind=wp), public, parameter :: a1410 = 1.5329179827876569731206322685e-1_wp real(kind=wp), public, parameter :: a1411 = 8.20105229563468988491666602057e-3_wp real(kind=wp), public, parameter :: a1412 = 7.56789766054569976138603589584e-3_wp real(kind=wp), public, parameter :: a1413 = -8.298e-3_wp real(kind=wp), public, parameter :: a151 = 3.18346481635021405060768473261e-2_wp real(kind=wp), public, parameter :: a156 = 2.83009096723667755288322961402e-2_wp real(kind=wp), public, parameter :: a157 = 5.35419883074385676223797384372e-2_wp real(kind=wp), public, parameter :: a158 = -5.49237485713909884646569340306e-2_wp real(kind=wp), public, parameter :: a1511 = -1.08347328697249322858509316994e-4_wp real(kind=wp), public, parameter :: a1512 = 3.82571090835658412954920192323e-4_wp real(kind=wp), public, parameter :: a1513 = -3.40465008687404560802977114492e-4_wp real(kind=wp), public, parameter :: a1514 = 1.41312443674632500278074618366e-1_wp real(kind=wp), public, parameter :: a161 = -4.28896301583791923408573538692e-1_wp real(kind=wp), public, parameter :: a166 = -4.69762141536116384314449447206_wp real(kind=wp), public, parameter :: a167 = 7.68342119606259904184240953878_wp real(kind=wp), public, parameter :: a168 = 4.06898981839711007970213554331_wp real(kind=wp), public, parameter :: a169 = 3.56727187455281109270669543021e-1_wp real(kind=wp), public, parameter :: a1613 = -1.39902416515901462129418009734e-3_wp real(kind=wp), public, parameter :: a1614 = 2.9475147891527723389556272149_wp real(kind=wp), public, parameter :: a1615 = -9.15095847217987001081870187138_wp real(kind=wp), public, parameter :: d41 = -0.84289382761090128651353491142e+01_wp real(kind=wp), public, parameter :: d46 = 0.56671495351937776962531783590_wp real(kind=wp), public, parameter :: d47 = -0.30689499459498916912797304727e+01_wp real(kind=wp), public, parameter :: d48 = 0.23846676565120698287728149680e+01_wp real(kind=wp), public, parameter :: d49 = 0.21170345824450282767155149946e+01_wp real(kind=wp), public, parameter :: d410 = -0.87139158377797299206789907490_wp real(kind=wp), public, parameter :: d411 = 0.22404374302607882758541771650e+01_wp real(kind=wp), public, parameter :: d412 = 0.63157877876946881815570249290_wp real(kind=wp), public, parameter :: d413 = -0.88990336451333310820698117400e-01_wp real(kind=wp), public, parameter :: d414 = 0.18148505520854727256656404962e+02_wp real(kind=wp), public, parameter :: d415 = -0.91946323924783554000451984436e+01_wp real(kind=wp), public, parameter :: d416 = -0.44360363875948939664310572000e+01_wp real(kind=wp), public, parameter :: d51 = 0.10427508642579134603413151009e+02_wp real(kind=wp), public, parameter :: d56 = 0.24228349177525818288430175319e+03_wp real(kind=wp), public, parameter :: d57 = 0.16520045171727028198505394887e+03_wp real(kind=wp), public, parameter :: d58 = -0.37454675472269020279518312152e+03_wp real(kind=wp), public, parameter :: d59 = -0.22113666853125306036270938578e+02_wp real(kind=wp), public, parameter :: d510 = 0.77334326684722638389603898808e+01_wp real(kind=wp), public, parameter :: d511 = -0.30674084731089398182061213626e+02_wp real(kind=wp), public, parameter :: d512 = -0.93321305264302278729567221706e+01_wp real(kind=wp), public, parameter :: d513 = 0.15697238121770843886131091075e+02_wp real(kind=wp), public, parameter :: d514 = -0.31139403219565177677282850411e+02_wp real(kind=wp), public, parameter :: d515 = -0.93529243588444783865713862664e+01_wp real(kind=wp), public, parameter :: d516 = 0.35816841486394083752465898540e+02_wp real(kind=wp), public, parameter :: d61 = 0.19985053242002433820987653617e+02_wp real(kind=wp), public, parameter :: d66 = -0.38703730874935176555105901742e+03_wp real(kind=wp), public, parameter :: d67 = -0.18917813819516756882830838328e+03_wp real(kind=wp), public, parameter :: d68 = 0.52780815920542364900561016686e+03_wp real(kind=wp), public, parameter :: d69 = -0.11573902539959630126141871134e+02_wp real(kind=wp), public, parameter :: d610 = 0.68812326946963000169666922661e+01_wp real(kind=wp), public, parameter :: d611 = -0.10006050966910838403183860980e+01_wp real(kind=wp), public, parameter :: d612 = 0.77771377980534432092869265740_wp real(kind=wp), public, parameter :: d613 = -0.27782057523535084065932004339e+01_wp real(kind=wp), public, parameter :: d614 = -0.60196695231264120758267380846e+02_wp real(kind=wp), public, parameter :: d615 = 0.84320405506677161018159903784e+02_wp real(kind=wp), public, parameter :: d616 = 0.11992291136182789328035130030e+02_wp real(kind=wp), public, parameter :: d71 = -0.25693933462703749003312586129e+02_wp real(kind=wp), public, parameter :: d76 = -0.15418974869023643374053993627e+03_wp real(kind=wp), public, parameter :: d77 = -0.23152937917604549567536039109e+03_wp real(kind=wp), public, parameter :: d78 = 0.35763911791061412378285349910e+03_wp real(kind=wp), public, parameter :: d79 = 0.93405324183624310003907691704e+02_wp real(kind=wp), public, parameter :: d710 = -0.37458323136451633156875139351e+02_wp real(kind=wp), public, parameter :: d711 = 0.10409964950896230045147246184e+03_wp real(kind=wp), public, parameter :: d712 = 0.29840293426660503123344363579e+02_wp real(kind=wp), public, parameter :: d713 = -0.43533456590011143754432175058e+02_wp real(kind=wp), public, parameter :: d714 = 0.96324553959188282948394950600e+02_wp real(kind=wp), public, parameter :: d715 = -0.39177261675615439165231486172e+02_wp real(kind=wp), public, parameter :: d716 = -0.14972683625798562581422125276e+03_wp","tags":"","loc":"module/dop853_constants.html","title":"dop853_constants – dop853"},{"text":"Uses: dop853_module dop853_constants iso_fortran_env pyplot_module program~~dop853_test~~UsesGraph program~dop853_test dop853_test module~dop853_constants dop853_constants module~dop853_constants->program~dop853_test module~dop853_module dop853_module module~dop853_constants->module~dop853_module pyplot_module pyplot_module pyplot_module->program~dop853_test module~dop853_module->program~dop853_test iso_fortran_env iso_fortran_env iso_fortran_env->program~dop853_test iso_fortran_env->module~dop853_constants iso_fortran_env->module~dop853_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Driver for dop853 on van der Pol's equation. See also Based on dr_dop853.f Results Note This requires pyplot-fortran . Variables Type Attributes Name Initial integer, parameter :: n = 2 dimension of the system integer, parameter, dimension(n) :: icomp = [1, 2] indices of y where we need dense output integer, parameter :: iout = 3 output routine (and dense output) is used during integration real(kind=wp), parameter :: tol = 1.0e-12_wp required (relative) tolerance real(kind=wp), parameter :: x0 = 0.0_wp initial x value real(kind=wp), parameter :: xf = 100.0_wp endpoint of integration real(kind=wp), parameter, dimension(n) :: y0 = [0.0_wp, 0.1_wp] initial y value real(kind=wp), parameter :: dx = 0.01_wp time step for dense output logical, parameter :: make_plots = .true. use pyplot to generate plots. type( dop853_class ) :: prop real(kind=wp), dimension(n) :: y real(kind=wp), dimension(1) :: rtol real(kind=wp), dimension(1) :: atol real(kind=wp) :: x real(kind=wp) :: xend integer :: i integer :: idid integer :: j integer :: nfcn integer :: nstep integer :: naccpt integer :: nrejct logical :: status_ok type(pyplot) :: plt real(kind=wp), dimension(:), allocatable :: t_vec real(kind=wp), dimension(:), allocatable :: y_vec real(kind=wp), dimension(:), allocatable :: yp_vec Subroutines subroutine solout (me, nr, xold, x, y, irtrn, xout) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(inout) :: me integer, intent(in) :: nr real(kind=wp), intent(in) :: xold real(kind=wp), intent(in) :: x real(kind=wp), intent(in), dimension(:) :: y integer, intent(inout) :: irtrn real(kind=wp), intent(out) :: xout the point where we want the next output reported Description Prints solution at equidistant output-points\n  by using contd8 , the continuous collocation solution.\n  This is for an iout=3 case. subroutine solout2 (me, nr, xold, x, y, irtrn, xout) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(inout) :: me integer, intent(in) :: nr real(kind=wp), intent(in) :: xold real(kind=wp), intent(in) :: x real(kind=wp), intent(in), dimension(:) :: y integer, intent(inout) :: irtrn real(kind=wp), intent(out) :: xout not used for iout=1 . Description Prints a normal step from dop853 (for iout=1 ). subroutine fvpol (me, x, y, f) Arguments Type Intent Optional Attributes Name class( dop853_class ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in), dimension(:) :: y  [y, y' ]  real(kind=wp), intent(out), dimension(:) :: f  [y', y'' ]  Description Right-hand side of van der Pol's equation:\n  y'' = \\mu(1-y&#94;2)y' - y . Source Code program dop853_test use dop853_module use dop853_constants use iso_fortran_env , only : output_unit use pyplot_module implicit none integer , parameter :: n = 2 !! dimension of the system integer , dimension ( n ), parameter :: icomp = [ 1 , 2 ] !! indices of `y` where we need dense output integer , parameter :: iout = 3 !! output routine (and dense output) is used during integration real ( wp ), parameter :: tol = 1.0e-12_wp !! required (relative) tolerance real ( wp ), parameter :: x0 = 0.0_wp !! initial `x` value real ( wp ), parameter :: xf = 10 0.0_wp !! endpoint of integration real ( wp ), dimension ( n ), parameter :: y0 = [ 0.0_wp , 0.1_wp ] !! initial `y` value real ( wp ), parameter :: dx = 0.01_wp !! time step for dense output logical , parameter :: make_plots = . true . !! use pyplot to generate plots. type ( dop853_class ) :: prop real ( wp ), dimension ( n ) :: y real ( wp ), dimension ( 1 ) :: rtol , atol real ( wp ) :: x , xend integer :: i , idid , j , nfcn , nstep , naccpt , nrejct logical :: status_ok type ( pyplot ) :: plt real ( wp ), dimension (:), allocatable :: t_vec , y_vec , yp_vec x = x0 y = y0 xend = xf rtol = tol atol = tol call prop % initialize ( fcn = fvpol , & n = n , & solout = solout , & icomp = icomp , & nstiff = 1 , & status_ok = status_ok ) !all other parameters use defaults if ( status_ok ) then call prop % integrate ( x , y , xend , rtol , atol , iout , idid ) call prop % info ( nfcn , nstep , naccpt , nrejct ) if ( make_plots ) then t_vec = [ t_vec , x ] !last point y_vec = [ y_vec , y ( 1 )] yp_vec = [ yp_vec , y ( 2 )] end if ! print final solution write ( output_unit , '(1X,A,F6.2,A,2E18.10)' ) & 'x =' , x , '    y =' , y ( 1 ), y ( 2 ) ! print statistics write ( output_unit , '(A,D8.2)' ) '       tol=' , tol write ( output_unit , '(A,I5,A,I4,A,I4,A,I3)' ) & ' fcn=' , nfcn , ' step=' , nstep , ' accpt=' , naccpt , ' rejct=' , nrejct ! plot: if ( make_plots ) then call plt % initialize ( grid = . true ., xlabel = 'y(x)' ,& ylabel = 'y''(x)' ,& title = 'van der Pol''s Equation ($\\mu = 0.2$)' , legend = . true .) call plt % add_plot ( y_vec , yp_vec , label = 'Forward' ,& linestyle = 'r-' , linewidth = 2 ,& xlim = [ - 3.0_wp , 3.0_wp ], ylim = [ - 3.0_wp , 3.0_wp ]) call plt % savefig ( 'dop853_forward.png' ) call plt % destroy () deallocate ( t_vec ) deallocate ( y_vec ) deallocate ( yp_vec ) end if !-------------------------------------------------- write ( * , * ) '' write ( * , * ) 'backwards test' write ( * , * ) '' call prop % destroy () call prop % initialize ( fcn = fvpol , n = n , solout = solout2 , status_ok = status_ok ) call prop % integrate ( x , y , x0 , rtol , atol , iout = 1 , idid = idid ) write ( * , * ) '' write ( * , * ) 'error:' , norm2 ( y - y0 ) write ( * , * ) '' ! plot: if ( make_plots ) then call plt % initialize ( grid = . true ., xlabel = 'y(x)' ,& ylabel = 'y''(x)' ,& title = 'van der Pol''s Equation ($\\mu = 0.2$)' , legend = . true .) call plt % add_plot ( y_vec , yp_vec , label = 'Backward' ,& linestyle = 'r-' , linewidth = 2 ,& xlim = [ - 3.0_wp , 3.0_wp ], ylim = [ - 3.0_wp , 3.0_wp ]) call plt % savefig ( 'dop853_backward.png' ) call plt % destroy () end if else write ( output_unit , '(A)' ) 'error calling INITIALIZE.' end if contains !***************************************************************************************** !******************************************************************************* !> !  Prints solution at equidistant output-points !  by using [[contd8]], the continuous collocation solution. !  This is for an `iout=3` case. ! !@note This routine uses Fortran 2008 LHS automatic allocations. subroutine solout ( me , nr , xold , x , y , irtrn , xout ) implicit none class ( dop853_class ), intent ( inout ) :: me integer , intent ( in ) :: nr real ( wp ), intent ( in ) :: xold real ( wp ), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y integer , intent ( inout ) :: irtrn real ( wp ), intent ( out ) :: xout !! the point where we want the next output reported if ( nr == 1 ) then write ( output_unit , '(1X,A,F6.2,A,2E18.10,A,I4)' ) & 'x =' , x ,& '    y =' , y ( 1 ), y ( 2 ),& '    nstep =' , nr - 1 xout = dx else do if ( x < xout ) exit write ( output_unit , '(1X,A,F6.2,A,2E18.10,A,I4)' ) & 'x =' , xout ,& '    y =' ,& prop % contd8 ( 1 , xout ),& prop % contd8 ( 2 , xout ),& '    nstep =' , nr - 1 xout = xout + dx end do end if if ( make_plots ) then if ( allocated ( t_vec )) then !fortran 2008 lhs allocations t_vec = [ t_vec , x ] y_vec = [ y_vec , y ( 1 )] yp_vec = [ yp_vec , y ( 2 )] else t_vec = [ x ] y_vec = [ y ( 1 )] yp_vec = [ y ( 2 )] end if end if end subroutine solout !******************************************************************************* !******************************************************************************* !> !  Prints a normal step from [[dop853]] (for `iout=1`). ! !@note This routine uses Fortran 2008 LHS automatic allocations. subroutine solout2 ( me , nr , xold , x , y , irtrn , xout ) implicit none class ( dop853_class ), intent ( inout ) :: me integer , intent ( in ) :: nr real ( wp ), intent ( in ) :: xold real ( wp ), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y integer , intent ( inout ) :: irtrn real ( wp ), intent ( out ) :: xout !! not used for `iout=1`. write ( output_unit , '(1X,A,F6.2,A,2E18.10,A,I4)' ) & 'x =' , x ,& '    y =' , y ( 1 ), y ( 2 ),& '    nstep =' , nr - 1 if ( make_plots ) then if ( allocated ( t_vec )) then t_vec = [ t_vec , x ] y_vec = [ y_vec , y ( 1 )] yp_vec = [ yp_vec , y ( 2 )] else t_vec = [ x ] y_vec = [ y ( 1 )] yp_vec = [ y ( 2 )] end if end if end subroutine solout2 !******************************************************************************* !******************************************************************************* !> ! Right-hand side of van der Pol's equation: !  y'' = \\mu(1-y&#94;2)y' - y . ! !### Reference ! * Weisstein, Eric W. \"[van der Pol Equation](http://mathworld.wolfram.com/vanderPolEquation.html).\" !   From MathWorld--A Wolfram Web Resource. ! !@note The [original code](http://www.unige.ch/~hairer/prog/nonstiff/dr_dop853.f) !      had a slightly different equation. subroutine fvpol ( me , x , y , f ) implicit none class ( dop853_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y !!  [y, y' ]  real ( wp ), dimension (:), intent ( out ) :: f !!  [y', y'' ]  real ( wp ), parameter :: mu = 0.2_wp !!  \\mu  in van der Pol's equation. f ( 1 ) = y ( 2 ) f ( 2 ) = mu * ( 1.0_wp - y ( 1 ) ** 2 ) * y ( 2 ) - y ( 1 ) end subroutine fvpol !******************************************************************************* end program dop853_test","tags":"","loc":"program/dop853_test.html","title":"dop853_test – dop853"}]}